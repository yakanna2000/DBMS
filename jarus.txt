
✅ OOPS (Object-Oriented Programming System)
1. Definition

OOP is a programming paradigm based on the concept of objects, which contain data (fields/attributes) and methods (functions/behaviors).
It helps in building modular, reusable, and maintainable code.

In Java → Everything is an object.

✅ Four Main Types / Pillars of OOP
🔹 1. Encapsulation (Data Hiding)

   *  Wrapping data (variables) and code (methods) together into a single unit (class).
    
   *  Access is controlled using access modifiers (private, public, protected).
    
    * Prevents unauthorized access.

👉 Real-Time Example:

         * In a banking application, your account balance is not directly accessible.
        
       *  You can only access it using deposit/withdraw methods.
        
        * This protects the balance from unauthorized modification.

Example (Encapsulation with Getter/Setter):

class BankAccount {
    private double balance;  // private → hidden data

    // public getter and setter
    public void setBalance(double amount) {
        if (amount > 0) balance = amount;
    }

    public double getBalance() {
        return balance;
    }
}

public class Main {
    public static void main(String[] args) {
        BankAccount acc = new BankAccount();
        acc.setBalance(5000);   // secure update
        System.out.println("Balance: " + acc.getBalance());
    }
}


👉 Balance is hidden and accessed only via methods.

🔹 2. Inheritance (Code Reusability)

      * Mechanism where one class (child/subclass) inherits properties & methods from another class (parent/superclass).
      
    *   Promotes reusability and avoids duplicate code.
      
     *  Achieved using extends keyword in Java.

👉 Real-Time Example:

 * In a Ride-Sharing App (Uber/Ola),

       * Vehicle is a parent class.

        * Car, Bike, Auto inherit properties like start(), stop(), fuelType().


Types of Inheritance in Java:

    * Single (one parent → one child)

   * Multilevel (grandparent → parent → child)

   * Hierarchical (one parent → many children)

  * ❌ Multiple inheritance (not supported with classes, only via interfaces).

Example:

class Vehicle {
    void start() {
        System.out.println("Vehicle is starting...");
    }
}

class Car extends Vehicle {
    void honk() {
        System.out.println("Car is honking...");
    }
}

public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        car.start();  // inherited from Vehicle
        car.honk();
    }
}


🔹 3. Polymorphism (Many Forms)

One action behaves differently in different situations.

Two types:

1.Compile-time Polymorphism (Method Overloading)

   * Same method name, different parameter list.

2.Runtime Polymorphism (Method Overriding)

    * Subclass provides a specific implementation of a method defined in superclass.


👉 Real-Time Example:

* In an E-commerce Payment System (Amazon, Flipkart),

          * Payment can be done via CreditCard, UPI, NetBanking, Wallet.
          
         *  The method is the same → pay(), but implementation differs.

Example (Overloading + Overriding):

class Calculator {
    int add(int a, int b) {
        return a + b;
    }
    double add(double a, double b) { // Overloading
        return a + b;
    }
}

class Animal {
    void sound() {
        System.out.println("Animal makes sound");
    }
}
class Dog extends Animal {
    void sound() { // Overriding
        System.out.println("Dog barks");
    }
}

public class Main {
    public static void main(String[] args) {
        Calculator c = new Calculator();
        System.out.println(c.add(2, 3));       // calls int version
        System.out.println(c.add(2.5, 3.5));   // calls double version

        Animal a = new Dog();
        a.sound();   // Runtime → "Dog barks"
    }
}



🔹 4. Abstraction (Hiding Implementation Details)

* Hides internal implementation and shows only essential features.

* Achieved using:

    * Abstract classes (using abstract keyword).

  * Interfaces (pure abstraction, from Java 8 → default & static methods).

👉 Real-Time Example:

 * In an ATM Machine,

        * You press buttons like Withdraw, Deposit, Balance Inquiry.
        
       *  You don’t know how internally ATM communicates with the bank servers.
        
        * You just see the functionality (interface), not the implementation.

Example:

abstract class Shape {
    abstract void draw();  // abstract method (no body)
}

class Circle extends Shape {
    void draw() {
        System.out.println("Drawing Circle");
    }
}

public class Main {
    public static void main(String[] args) {
        Shape s = new Circle();
        s.draw();   // abstraction → only know "draw()", not internal logic
    }
}
----------------------------------------------------------------------------------------

The 4 core features of Java that stand out are:

1.Object-Oriented

2.Platform Independent (WORA)

3.Robust & Secure

4.Multithreaded

Let’s go one by one 👇

✅ 1. Object-Oriented
Meaning:

        Java is based on the concept of Objects and Classes.
        
        Real-world entities (like Car, Employee, BankAccount) are modeled as objects.
        
        OOP principles (Encapsulation, Inheritance, Polymorphism, Abstraction) make the system modular, reusable, and maintainable.

Real-Time Example:

 In a Banking System,

        Customer → object with data like name, balance.
        
        Account → object with deposit/withdraw methods.

 These map directly into Java classes.

Code Example:
class Employee {
    String name;
    int salary;

    void work() {
        System.out.println(name + " is working");
    }
}

public class Main {
    public static void main(String[] args) {
        Employee emp = new Employee();
        emp.name = "John";
        emp.salary = 50000;
        emp.work();
    }
}


👉 This shows how real-life entities are represented as objects.

✅ 2. Platform Independent (Write Once, Run Anywhere)
Meaning:

        In Java, code is compiled into bytecode (.class file) by the Java compiler.
        
        This bytecode runs on the JVM (Java Virtual Machine), not directly on the OS.
        
        So the same Java program can run on Windows, Linux, Mac, Android — without rewriting.

👉 Famous slogan: “Write Once, Run Anywhere (WORA)”.

Real-Time Example:
        
        If a company builds an ERP system in Java, they don’t have to rewrite it separately for Windows, Linux, and macOS.
        
        They just ship the .class files, and JVM takes care of execution on different systems.

Diagram (simplified):
Java Code (.java) → javac → Bytecode (.class) → JVM → OS → Hardware

Code Example:
# Compile
javac Hello.java   # produces Hello.class (bytecode)

# Run (any OS with JVM installed)
java Hello


👉 This cross-platform support is one of the biggest reasons Java is so widely used.

✅ 3. Robust & Secure
Meaning:

Robust (Strong): Java is designed to reduce runtime errors.

        Automatic Garbage Collection → no memory leaks.
        
        Exception Handling → catches errors gracefully.
        
        No explicit pointers → prevents unsafe memory access.

Secure: Java programs run inside the JVM sandbox.

        Bytecode is verified before execution.
        
        Security Manager controls access to system resources.
        
        No pointer manipulation → prevents hacking/unauthorized memory access.

Real-Time Example:

        In Banking Applications (like SBI, HDFC net banking), security is critical.
        
        Java’s built-in security (no pointer misuse) and error handling make it safer compared to C/C++.

Code Example (Robustness via Exception Handling):

public class Main {
    public static void main(String[] args) {
        try {
            int x = 10 / 0;  // risky code
        } catch (ArithmeticException e) {
            System.out.println("Error handled: " + e.getMessage());
        }
        System.out.println("Program continues...");
    }
}


👉 Without handling, the program would crash. With exception handling, it runs smoothly.

✅ 4. Multithreaded
Meaning:

          Java supports multithreading, i.e., running multiple tasks in parallel within a single program.
          
          Each thread runs independently but shares common resources.
          
          This makes applications faster and efficient.

Real-Time Example:

  In a video streaming app (like YouTube):

            One thread → plays video.
            
            Another thread → downloads data.
            
            Another thread → listens for user input (pause/play).

👉 All tasks run simultaneously, thanks to multithreading.

Code Example:
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread running: " + Thread.currentThread().getName());
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        MyThread t2 = new MyThread();
        
        t1.start();
        t2.start();
    }
}


👉 Output shows both threads running concurrently.


---------------------------------------------------------------------------------------------------------
JAVA
1.What is loose coupling and strong coupling?

✅ Interview-Style Answer
1. Definition

Coupling in Java means the degree of dependency between two classes or modules.

It answers: “How much does Class A know about Class B?”

👉 Two types:

Tight (Strong) Coupling → High dependency.

Loose Coupling → Low dependency.

2. Strong (Tight) Coupling

          One class is highly dependent on another class’s implementation.
          
          If one class changes, the other class must change too.
          
          This makes the system hard to maintain, extend, or test.
Real-World Analogy: 

A smartphone with a soldered, non-removable battery. If the battery dies, you can't just swap it out; you have to take the whole phone apart (modify the existing system) to replace it. The phone and battery are tightly coupled.

Example (Tight Coupling without interfaces):

class PetrolEngine {
    void start() {
        System.out.println("Petrol Engine Starting...");
    }
}

class Car {
    PetrolEngine engine;  // directly depends on PetrolEngine

    Car() {
        engine = new PetrolEngine(); // strong coupling
    }

    void startCar() {
        engine.start();
    }
}

public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        car.startCar();  // Works only with PetrolEngine
    }
}


❌ Problem → If tomorrow we want a DieselEngine, we must modify the Car class. This shows tight coupling.

3. Loose Coupling

      One class depends only on abstraction (interface/abstract class), not a concrete implementation.
      
      We can change implementations without modifying the dependent class.
      
      This makes the system flexible, reusable, testable, and maintainable.

Real-World Analogy:

A standardized power socket. Your lamp (the Car) is designed to work with any device that plugs into the socket and provides electricity (the Engine interface). You can plug in a halogen bulb (PowerfulEngine), an LED bulb (ElectricEngine), or even a night light (TestEngine) without rewiring the lamp itself. The socket defines the contract (voltage, plug shape).

Example (Loose Coupling using Interface):

// Abstraction
interface Engine {
    void start();
}

// Implementations
class PetrolEngine implements Engine {
    public void start() {
        System.out.println("Petrol Engine Starting...");
    }
}

class DieselEngine implements Engine {
    public void start() {
        System.out.println("Diesel Engine Starting...");
    }
}

// Car depends only on abstraction
class Car {
    private Engine engine;

    // Dependency Injection
    Car(Engine engine) {
        this.engine = engine;
    }

    void startCar() {
        engine.start();
    }
}

public class Main {
    public static void main(String[] args) {
        Engine petrol = new PetrolEngine();
        Car car1 = new Car(petrol);
        car1.startCar();

        Engine diesel = new DieselEngine();
        Car car2 = new Car(diesel);
        car2.startCar();
    }
}


✅ Advantage → Car doesn’t care if it’s PetrolEngine, DieselEngine, or ElectricEngine.
We can add new engines without modifying Car → Loose Coupling.

---------------------------------------------------------------------------------------------------------

 2. Data Structure mainly Trees concept

1. What is a Tree?
A Tree is a non-linear data structure that simulates a hierarchical tree structure. It's a collection of entities called nodes connected by edges. Each node contains a value and references to its children.

Why is it non-linear? Unlike arrays or linked lists which have a strict linear sequence, trees branch out, allowing for faster access and insertion/deletion than linear structures.

2. Key Terminology
Root: The topmost node in a tree (Node A in the diagram below).

Parent/Child: A node connected to another node when moving away from the Root. (A is the parent of B and C. B and C are children of A).

Siblings: Nodes with the same parent (B and C are siblings).

Leaf (External) Node: A node with no children (D, E, F).

Internal Node: A node with at least one child (A, B, C).

Edge: The link connecting two nodes.

Path: A sequence of nodes and edges connecting a node with a descendant.

Depth: The number of edges from the root to the node. (Depth of A is 0, depth of B is 1).

Height: The number of edges on the longest path from the node to a leaf. (Height of the tree is the height of the root. Height of B is 1, height of A is 2).

Subtree: A tree consisting of a node and all of its descendants.

Visual Representation:

text
        A  (Root, Depth=0, Height=2)
       / \
      B   C (Siblings, Depth=1)
     / \   \
    D   E   F (Leaves, Depth=2)
    (Height=0)
3. Why are Trees Important? (Real-Time Examples)
File Systems: The directories and folders on your computer form a tree structure. The root directory (C:\ or /) has sub-directories (Program Files, Users), which themselves have more sub-directories.

Domain Name System (DNS): The organization of domain names (com, org, google, www) is a tree, allowing for efficient routing of internet traffic.

Organization Hierarchy: The CEO at the root, followed by VPs, managers, and employees. This is a classic tree.

JARUS-specific Example - Decision Making for Drones:
An autonomous drone uses a tree structure called a Behavior Tree to make decisions.

The root node might be "Complete Delivery".

Its children could be "Navigate to Destination" and "Handle Obstacle".

"Navigate to Destination" might have children like "Calculate Path", "Maintain Altitude", and "Check Battery".

This allows the drone to traverse the tree, making complex decisions based on environmental inputs (e.g., if an obstacle is detected, it moves to the "Handle Obstacle" branch).

4. Common Types of Trees (From Most to Least Important for Interviews)
a) Binary Tree
A tree where each node has at most two children, typically referred to as the left child and right child.

java
class TreeNode {
    int value;
    TreeNode left;  // Reference to left child
    TreeNode right; // Reference to right child

    TreeNode(int value) {
        this.value = value;
        this.right = null;
        this.left = null;
    }
}
b) Binary Search Tree (BST)
A Binary Tree with a special ordering property:

For any node, all values in its left subtree are less than the node's value.

All values in its right subtree are greater than the node's value.

This property enables very efficient searching, insertion, and deletion (Average Time: O(log n)).

Example:

text
        10
       /  \
      5    15
     / \     \
    3   7     20
Searching for 7: Start at 10 -> go left to 5 -> go right to 7 (Found!).

c) Balanced vs. Unbalanced Trees
Balanced (e.g., AVL, Red-Black Trees): A tree where the height of the left and right subtrees of any node differ by at most 1. This ensures operations remain O(log n).

Unbalanced: A tree that can degenerate into a linked list in the worst case, making operations O(n).

text
// An unbalanced BST (worst-case scenario - just a linked list)
1
 \
  2
   \
    3
     \
      4
d) Other Important Types
Trie (Prefix Tree): Specialized for storing strings. Used for autocomplete features and IP routing. Each node represents a character.

Heap: A complete binary tree where each node is greater (max-heap) or smaller (min-heap) than its children. Used for efficient priority queues and sorting (Heapsort).

B-Tree / B+ Tree: Trees with more than two children per node. Crucial for database indexing and file systems because they minimize disk I/O.

5. Tree Traversals (VISITING EVERY NODE)
This is a very common interview question. The four main ways to traverse a binary tree:

1. Inorder (Left, Root, Right)

Result: Visits nodes in ascending order in a BST.

Code:

java
void inorderTraversal(TreeNode node) {
    if (node == null) return;
    inorderTraversal(node.left);   // 1. Traverse left subtree
    System.out.print(node.value + " "); // 2. Visit the root
    inorderTraversal(node.right);  // 3. Traverse right subtree
}
// Output for the BST example: 3, 5, 7, 10, 15, 20
2. Preorder (Root, Left, Right)

Use Case: Good for creating a copy of the tree.

Code:

java
void preorderTraversal(TreeNode node) {
    if (node == null) return;
    System.out.print(node.value + " "); // 1. Visit the root
    preorderTraversal(node.left);   // 2. Traverse left subtree
    preorderTraversal(node.right);  // 3. Traverse right subtree
}
// Output: 10, 5, 3, 7, 15, 20
3. Postorder (Left, Right, Root)

Use Case: Good for deleting the tree (you delete children before the parent).

Code:

java
void postorderTraversal(TreeNode node) {
    if (node == null) return;
    postorderTraversal(node.left);  // 1. Traverse left subtree
    postorderTraversal(node.right); // 2. Traverse right subtree
    System.out.print(node.value + " "); // 3. Visit the root
}
// Output: 3, 7, 5, 20, 15, 10
4. Level Order (Breadth-First Search - BFS)

How: Uses a queue. Visit nodes level by level.

Code:

java
void levelOrderTraversal(TreeNode root) {
    if (root == null) return;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);

    while (!queue.isEmpty()) {
        TreeNode currentNode = queue.poll();
        System.out.print(currentNode.value + " ");

        if (currentNode.left != null) queue.add(currentNode.left);
        if (currentNode.right != null) queue.add(currentNode.right);
    }
}
// Output: 10, 5, 15, 3, 7, 20
------------------------------------------------------------------------------------------------------------
 3. What is input and output buffering?

🔹 What is Buffering?

A buffer is just a temporary memory (like a box) that stores data while it is being transferred between two places (like between a program and a file, or program and network).

The idea is: instead of sending/receiving data one small piece at a time (which is slow), we collect data in the buffer and then send/receive in bulk (faster).

🔹 Input Buffering

Definition: Input buffering means when we read data (like from a file, keyboard, or network), it is first stored in a buffer in memory. The program then reads from that buffer instead of directly from the device.

Why? Because reading data directly from devices (like disk or keyboard) is slow compared to memory operations.

So buffering reduces the number of device accesses and speeds up input.

✅ Example 1 (Keyboard input):
When you type on the keyboard, the characters don’t directly go to your program.
They are first collected in a buffer (usually until you press Enter). Then the program reads the whole line from the buffer.

✅ Example 2 (File Input in Java):

import java.io.*;

public class InputBufferExample {
    public static void main(String[] args) throws Exception {
        FileReader fr = new FileReader("data.txt");
        BufferedReader br = new BufferedReader(fr); // Input buffering

        String line;
        while((line = br.readLine()) != null) {
            System.out.println(line);
        }
        br.close();
    }
}


Here, instead of reading the file character by character (slow),
BufferedReader reads a big chunk of data at once into memory and gives it line by line → Faster.

🔹 Output Buffering

Definition: Output buffering means when we write data (to file, screen, or network), it is not written immediately. Instead, it is stored in a buffer and written all at once when the buffer is full or explicitly flushed.

Why? Because writing data to devices (disk, printer, network) is slow. Buffering makes it efficient.

✅ Example 1 (System.out.print in Java):
When you use System.out.print("Hello"), sometimes it does not appear instantly on the console until you call System.out.flush() or print a newline (println). That’s because of output buffering.

✅ Example 2 (File Output in Java):

import java.io.*;

public class OutputBufferExample {
    public static void main(String[] args) throws Exception {
        FileWriter fw = new FileWriter("output.txt");
        BufferedWriter bw = new BufferedWriter(fw); // Output buffering

        bw.write("Hello, this is written using buffering!");
        bw.newLine();
        bw.write("Data is stored in buffer first.");
        
        bw.flush(); // flush buffer to file
        bw.close();
    }
}


Here, data is first written to the buffer.
Only when we call flush() or close(), the buffer contents go to the file.

🔹 Real-Life Analogy (Easy to Remember in Interview)

Imagine writing letters and sending them by courier:

Without buffering → You send each letter one by one (slow, costly).

With buffering → You collect all letters in an envelope (buffer) and send them together (fast, efficient).

Similarly:

Input buffering = Receiving courier packages in bulk, then reading inside one by one.

Output buffering = Collecting letters in an envelope before sending out.

✅ Interview Point:

Input/Output buffering is mainly used to improve performance by minimizing the number of slow I/O operations.

In Java, classes like BufferedReader, BufferedWriter, BufferedInputStream, and BufferedOutputStream use buffering.

-----------------------------------------------------------------------------------------------------------

 4. Java collections and why hashing is not included in collections?

Java Collections Framework

Definition:
Java Collections Framework (JCF) is a set of interfaces and classes that provide ready-made data structures (like List, Set, Queue, Map) and algorithms (like sorting, searching).

Goal: To make data storage, retrieval, and manipulation easier with reusable, consistent APIs.

👉 Main interfaces in Collections:

List – Ordered collection, allows duplicates (e.g., ArrayList, LinkedList).

Set – Unique elements, no duplicates (e.g., HashSet, TreeSet).

Queue – Follows FIFO, supports priority (e.g., PriorityQueue, LinkedList).

Map – Key-value pairs (e.g., HashMap, TreeMap).

Why Hashing is NOT directly part of Collections?

This is a tricky part—interviewers ask to see if you know the design perspective of Java.

🔹 1. Collections Framework is about "Collection of Objects"

Collection interface (root of the hierarchy) represents a group of individual objects (like a bag of items).

Hashing is not a collection type, it is an algorithm/technique used for fast data access.

👉 Example:

ArrayList, LinkedList, HashSet → all store objects.

But hashing is not a container; it’s a mechanism to organize and access data quickly.

🔹 2. Maps (like HashMap, Hashtable) do use hashing

Map is not a sub-interface of Collection (different hierarchy).

Why? Because a map stores key-value pairs, while a collection stores individual objects.

Hashing is implemented inside Map classes (like HashMap, Hashtable), but hashing itself is not exposed as a "collection".

👉 Example:

Map<String, Integer> studentMarks = new HashMap<>();
studentMarks.put("Alice", 85);
studentMarks.put("Bob", 90);

// Hashing is used internally to store/retrieve values quickly
System.out.println(studentMarks.get("Alice")); // O(1) lookup


Here, hashing is working inside HashMap, but you don’t see it directly in Collections.

🔹 3. Design Principle (Separation of Concerns)

Collections = data structures

Hashing = algorithm for storage/retrieval

If Java added "Hashing" as part of Collections, it would mix abstraction levels (data structures vs. algorithms).

That’s why Java designers kept hashing hidden inside implementation classes (HashMap, HashSet, Hashtable).

✅ Interview Answer (Crisp & Clear)

Java Collections Framework provides interfaces and classes like List, Set, Queue, and Map to store and manipulate groups of objects. Hashing, however, is not included directly because it is not a data structure by itself, but a technique used internally to achieve fast access in classes like HashMap, HashSet, and Hashtable. Also, Collection deals with individual objects, whereas Map stores key-value pairs, so Map is kept separate from the Collection hierarchy. This separation maintains clean design and abstraction.

--------------------------------------------------------------------------------------------------------------------------------------------------------------
Java Collections Framework Hierarchy

In Java, the Collections Framework is divided into two main parts:

Collection Interface (java.util.Collection) → for working with groups of objects.

Sub-interfaces: List, Set, Queue, Deque

Map Interface (java.util.Map) → for working with key-value pairs.

Not a child of Collection, but part of the framework.

Hierarchy Diagram (Textual Representation)
              Iterable (I)
                  |
            -----------------
            |               |
         Collection (I)     Map (I)
            |                  
   -------------------------
   |           |           |
  List (I)    Set (I)     Queue (I)
   |           |            |
ArrayList    HashSet      PriorityQueue
LinkedList   TreeSet      ArrayDeque
Vector       LinkedHashSet
Stack

Breakdown
1. Iterable (Root Interface)

Super interface of all collection classes.

Defines the method iterator() for iteration (used in enhanced for-loop).

2. Collection Interface

Defines core methods like add(), remove(), size(), clear(), etc.

Sub-interfaces of Collection:

List (Ordered, Allows Duplicates)

Implementations: ArrayList, LinkedList, Vector, Stack

Set (Unordered, No Duplicates)

Implementations: HashSet, LinkedHashSet, TreeSet

Queue (FIFO order, Can allow duplicates)

Implementations: PriorityQueue, ArrayDeque, LinkedList

3. Map Interface (Key-Value Pairs, No duplicate keys)

Implementations:

HashMap, LinkedHashMap, TreeMap, Hashtable

✅ Key Notes for Interview

Map is not a child of Collection, but it’s part of the Collections Framework.

Collection → works with elements.

Map → works with key-value pairs.

List → preserves order, allows duplicates.

Set → no duplicates.

Queue → follows FIFO/LIFO depending on implementation.
-----------------------------------------------------------------------------------------------------
 5. What are annotations in Java?

What are Annotations in Java?

Annotations in Java are metadata (extra information) that you can add to your code.
They do not directly affect program logic, but they provide instructions to the compiler, runtime, or frameworks.

Think of annotations as labels or tags you put on your code, so that tools or libraries can understand how to treat it.

Types of Annotations in Java

Java provides three main categories:

Built-in Annotations (provided by Java)

@Override → tells the compiler a method is overriding a superclass method.

@Deprecated → marks a method/class as outdated.

@SuppressWarnings → tells compiler to ignore warnings.

Meta-Annotations (annotations for annotations)

@Retention → tells how long the annotation is retained (source, class, runtime).

@Target → defines where annotation can be applied (method, class, field).

@Inherited → allows subclasses to inherit annotations.

Custom Annotations (user-defined)

You can create your own annotation using @interface.

Examples
1. Built-in Annotation Example
class Parent {
    void display() {
        System.out.println("Parent display");
    }
}

class Child extends Parent {
    @Override   // ensures overriding is correct
    void display() {
        System.out.println("Child display");
    }
}


✅ If you misspell display (like dispaly), the compiler throws an error because of @Override.

2. @Deprecated Example
class OldCode {
    @Deprecated
    void oldMethod() {
        System.out.println("This method is deprecated");
    }
}

class Test {
    public static void main(String[] args) {
        OldCode obj = new OldCode();
        obj.oldMethod(); // compiler shows warning
    }
}


👉 This warns developers that oldMethod() should not be used anymore.

3. Custom Annotation Example
import java.lang.annotation.*;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@interface MyAnnotation {
    String author() default "Unknown";
    int version() default 1;
}

class Demo {
    @MyAnnotation(author = "Yakanna", version = 2)
    public void myMethod() {
        System.out.println("Custom Annotation Example");
    }
}


Here we created a custom annotation @MyAnnotation and applied it to a method.
Frameworks like Spring, Hibernate use custom annotations heavily (e.g., @Autowired, @Entity, @RestController).

Interview Key Points

Annotations = Metadata (information about code).

They don’t change execution but guide compiler, runtime, or frameworks.

Used in frameworks (Spring Boot, JPA, Hibernate). Example:

@Entity → tells Hibernate this class maps to a database table.

@Autowired → tells Spring to inject a dependency.

🔥 Real-World Example:

In Spring Boot, instead of writing XML configs, we just use annotations:

@RestController
public class UserController {
    @GetMapping("/users")
    public String getUsers() {
        return "List of Users";
    }
}


Here:

@RestController → tells Spring this is a REST controller.

@GetMapping("/users") → maps HTTP GET request to getUsers() method.

----------------------------------------------------------------------------------------------------------------

 6. Whyis spring boot and framework introduced in Java?

The Problem: "Why was it needed?"
Imagine building a large, complex enterprise application for banking, e-commerce, or a company like JARUS (with drones, logistics, etc.) using only core Java (Java SE). You would face several major challenges:

Tight Coupling: Business logic (e.g., OrderService) would be directly instantiated with new inside other classes (e.g., OrderController). This makes the code rigid, hard to test, and difficult to modify.

java
// WITHOUT SPRING - Tightly Coupled, Hard to Test
public class OrderController {
    // The controller is hardcoded to use this specific service
    private OrderService orderService = new OrderService();

    public void processOrder() {
        orderService.process();
    }
}
Bolierplate Code: Common tasks like transaction management, security, and logging required writing the same repetitive, verbose code in every project.

java
// Manual Transaction Management Boilerplate (Simplified)
Connection conn = null;
try {
    conn = dataSource.getConnection();
    conn.setAutoCommit(false); // Begin transaction

    // ... business logic ...

    conn.commit(); // Commit transaction
} catch (SQLException e) {
    if (conn != null) conn.rollback(); // Rollback on error
} finally {
    if (conn != null) conn.close();
}
Painful Integration: Getting different technologies (e.g., Hibernate for ORM, Tomcat as a server, Jackson for JSON) to work together required a lot of manual configuration and wiring.

Configuration Hell: Managing dependencies and their versions using build tools like Ant or early Maven was complex. Configuring applications involved massive, unwieldy XML files.

In short, developers were spending more time on "plumbing" code (wiring things together) than on writing actual business logic (solving the real problem).

The Solution Part 1: Spring Framework
The Spring Framework was introduced to address these issues by providing a comprehensive programming and configuration model for modern Java-based enterprise applications.

Its core power comes from two principles:

Dependency Injection (DI) / Inversion of Control (IoC):
This is the heart of Spring. Instead of a class creating its own dependencies (new OrderService()), the dependencies are injected into it by the Spring IoC Container. The container is a framework that manages objects ("beans") and their life cycle.

How it solves coupling:

java
// WITH SPRING - Loosely Coupled, Easy to Test
@Controller
public class OrderController {

    // The dependency is declared but not created here
    @Autowired
    private OrderService orderService; // Spring injects this!

    public void processOrder() {
        orderService.process();
    }
}

@Service
public class OrderService {
    // Spring will automatically create one instance (a Singleton) of this service
}
Result: OrderController is no longer tied to OrderService. You can easily swap the implementation for testing (e.g., inject a MockOrderService) or for different environments.

Aspect-Oriented Programming (AOP):
Spring allows you to define cross-cutting concerns—functionality that applies across many parts of the application (like logging, security, transactions)—separately from the business logic. Spring then weaves them together automatically.

How it solves boilerplate:
You can declare a transaction requirement declaratively with an annotation, and Spring handles the boilerplate code shown earlier.

java
@Service
public class BankService {

    @Transactional // <- That's it! Spring handles begin/commit/rollback.
    public void transferMoney(Account from, Account to, double amount) {
        // ... your pure business logic here ...
        withdraw(from, amount);
        deposit(to, amount);
    }
}
What Spring Framework provided: A powerful, flexible toolbox for building enterprise apps by promoting loose coupling and reducing boilerplate.

The Solution Part 2: Spring Boot
Spring Framework was powerful, but it came with a cost: Complex Configuration. You still had to spend significant time writing XML or Java configuration to set up the framework itself, choose compatible library versions, and deploy your application.

Spring Boot was introduced to make Spring itself easier to use. Its mantra is "convention over configuration."

Spring Boot's key features:

Auto-Configuration: Spring Boot automatically configures your application based on the libraries (JARs) it finds on the classpath. If it sees H2 database in the classpath, it auto-configures an in-memory datasource. If it sees Spring MVC, it auto-configures a web server (Tomcat by default). You only need to override this configuration if you want non-default behavior.

Standalone Applications: Spring Boot allows you to package your application as a single, executable JAR file that has an embedded web server (Tomcat, Jetty, or Undertow). You don't need to deploy a WAR file to an external Tomcat server. You can just run java -jar myapp.jar.

Starter Dependencies: Simple Maven descriptors that bundle all the necessary dependencies for a specific functionality.

Need a web app? Add spring-boot-starter-web.

Need data access? Add spring-boot-starter-data-jpa.

Need security? Add spring-boot-starter-security.
This eliminates version conflicts and dependency hell.

Production-Ready Features: It provides built-in tools like Spring Boot Actuator for monitoring your application (health checks, metrics, info) and Spring Boot DevTools for fast developer restarts.

Real-Time Analogy
Core Java: Building a car from scratch. You have to manufacture every single screw, wire the electronics, and build the engine yourself. It's flexible but incredibly time-consuming.

Spring Framework: A kit car. You get a pre-built chassis, engine, and wiring harness (the Spring modules). You still have to assemble and connect all the parts yourself (the configuration), but you didn't have to forge the metal.

Spring Boot: A fully assembled, production-ready car. You just get in, turn the key, and drive. The "conventions" (the standard design) are already chosen for you, but you can still customize the paint and seats if you want.

Summary: Why They Were Introduced
Spring Framework	Spring Boot
Primary Goal	To solve application development complexity by enabling loose coupling and reducing boilerplate code via DI and AOP.	To solve Spring's configuration complexity and simplify deployment.
Key Concept	Dependency Injection & Aspect-Oriented Programming	Auto-Configuration & Convention Over Configuration
Analogy	A powerful toolbox with all the best tools.	A pre-assembled product built with those tools.
For an interview at JARUS: You can conclude by saying that these technologies allow developers to focus on the unique business logic of the domain (e.g., drone flight paths, logistics algorithms, sensor data processing) instead of the underlying plumbing, leading to more robust, maintainable, and faster-developed applications.

-------------------------------------------------------------------------------------------------------------------------------------------
7. Write example for dynamic polymorphism

Dynamic Polymorphism in Java

👉 Definition:
Dynamic polymorphism (also called Runtime Polymorphism) is when a method call is resolved at runtime instead of compile time.
This happens using method overriding (not method overloading).

Method Overloading = Compile-time polymorphism.

Method Overriding = Runtime polymorphism (dynamic).

Example of Dynamic Polymorphism
// Parent class
class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}

// Child class
class Dog extends Animal {
    @Override
    void sound() {
        System.out.println("Dog barks");
    }
}

// Another child class
class Cat extends Animal {
    @Override
    void sound() {
        System.out.println("Cat meows");
    }
}

public class DynamicPolymorphismExample {
    public static void main(String[] args) {
        Animal a;  // reference of parent class

        a = new Dog();   // object of Dog
        a.sound();       // Output: Dog barks

        a = new Cat();   // object of Cat
        a.sound();       // Output: Cat meows
    }
}

Explanation

We have a parent class (Animal) and child classes (Dog, Cat) that override the sound() method.

The parent class reference Animal a; can hold any child class object.

Which method gets executed depends on the object type at runtime, not the reference type.

👉 That’s why it is called Dynamic (Runtime) Polymorphism.

Real-Life Example

Think of a remote control (parent).

The same remote (reference) can control TV, AC, or Music System (child objects).

The button pressed (method call) will behave differently depending on which device is connected.

✅ Interview Tip:
When asked this question, always explain the difference between compile-time polymorphism (method overloading) and runtime polymorphism (method overriding), then write a method overriding example like above.

------------------------------------------------------------------------------------------------------------------------------

 8. Tell me about Finalize keyword

🔹 What is finalize in Java?

In Java, finalize() is a method in the Object class.
It is called by the Garbage Collector (GC) before destroying an object to allow the object to clean up resources (like closing files, releasing memory, disconnecting from networks, etc.).

👉 Think of it like a “last chance cleanup” before the object is deleted from memory.


2. How was it supposed to work?
The concept was part of Java's original design for resource management. The idea was:

When an object becomes eligible for garbage collection (i.e., no more live references point to it), the Garbage Collector is scheduled to run.

Before actually deleting the object and reclaiming its memory, the GC would call the object's finalize() method.

Inside the finalize() method, the object could release critical system resources that it was holding, such as:

File handles (FileInputStream, FileOutputStream)

Network sockets

Database connections

Native resources (memory allocated outside the JVM, e.g., through JNI)


🔹 Syntax of finalize()
protected void finalize() throws Throwable {
    // cleanup code
}


It is protected → So that subclasses can override it.

It can throw exceptions.

It is defined in java.lang.Object, so every class in Java can override it.

🔹 When is finalize() called?

When the Garbage Collector decides that an object is no longer reachable (no references exist).

Before the object’s memory is reclaimed, finalize() (if overridden) is called once.

⚠️ Important:

You cannot predict when finalize() will be called.

It may never be called if the program exits before GC runs.

🔹 Example of finalize()
class Demo {
    String name;

    Demo(String name) {
        this.name = name;
    }

    // Override finalize method
    @Override
    protected void finalize() throws Throwable {
        System.out.println("Finalize called for: " + name);
    }
}

public class FinalizeExample {
    public static void main(String[] args) {
        Demo d1 = new Demo("Object1");
        Demo d2 = new Demo("Object2");

        d1 = null; // eligible for GC
        d2 = null; // eligible for GC

        System.gc(); // Request JVM to run Garbage Collector

        System.out.println("Main method completed.");
    }
}

✅ Output (may vary):
Main method completed.
Finalize called for: Object2
Finalize called for: Object1


(Notice: The order is not guaranteed.)

🔹 Why is finalize() discouraged?

Unpredictable: You don’t know when or if it will run.

Performance cost: It makes Garbage Collection slower.

Deprecated: Since Java 9, finalize() is marked as deprecated because better resource management techniques exist.

🔹 Best Alternative to finalize()

Instead of using finalize(), we should use:

try-with-resources (Java 7+) → Automatically closes resources like files, DB connections.

AutoCloseable interface → Custom cleanup logic.

Explicit cleanup methods → Example: close(), disconnect(), etc.

🔹 Real-life Analogy 🚗

Think of finalize() like a car scrap process:

When your car is no longer usable (object not referenced), it goes to a scrap yard (GC).

Before scrapping, you may want to remove the stereo system or personal items (cleanup in finalize()).

But you don’t know exactly when the car will be scrapped → Same unpredictability with finalize().



The Bottom Line for Your Interview
"The finalize method was an old, flawed idea for cleanup in Java. You couldn't rely on it because it might run too late or not at all. It's now deprecated. Today, we always use try-with-resources because it makes cleanup immediate and predictable."
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 9. What is the relationship between classes in java?


🔹 Relationship Between Classes in Java

In Java, classes relate to each other mainly in two broad ways:

IS-A Relationship (Inheritance)

HAS-A Relationship (Association/Composition/Aggregation)

1. IS-A Relationship (Inheritance)

This means one class is a subtype of another.

Implemented using extends (for classes) and implements (for interfaces).

It represents specialization: Child class extends Parent class to reuse and add functionality.

✅ Example:

class Vehicle {
    void start() {
        System.out.println("Vehicle starting...");
    }
}

class Car extends Vehicle {  // IS-A relationship
    void playMusic() {
        System.out.println("Playing music...");
    }
}

public class Main {
    public static void main(String[] args) {
        Car c = new Car();
        c.start();       // Inherited from Vehicle
        c.playMusic();   // Defined in Car
    }
}


📌 Here, Car IS-A Vehicle. This allows code reusability and polymorphism.

2. HAS-A Relationship (Composition & Aggregation)

This means a class contains another class as a field (member variable).

Composition (Strong HAS-A):

One class owns another completely.

If the container object is destroyed → the contained object is also destroyed.

✅ Example:

class Engine {
    void run() {
        System.out.println("Engine running...");
    }
}

class Car {
    private Engine engine;   // Composition

    Car() {
        engine = new Engine();  // Car owns Engine
    }

    void startCar() {
        engine.run();  // Car uses Engine
        System.out.println("Car started!");
    }
}


📌 Here, Car HAS-A Engine. Without Car, engine object doesn’t exist → Composition.

Aggregation (Weak HAS-A):

A class contains another class, but they are independent.

If container is destroyed → the contained object can still exist.

✅ Example:

class Student {
    String name;
    Student(String name) {
        this.name = name;
    }
}

class Department {
    private String deptName;
    private List<Student> students;   // Aggregation

    Department(String deptName, List<Student> students) {
        this.deptName = deptName;
        this.students = students;  // Dept HAS-A Student
    }
}


📌 Here, Department HAS-A Student. Even if Department is deleted, students can still exist → Aggregation.

3. Dependency Relationship (Uses-A)

When one class depends on another class temporarily (usually as a method parameter).

Not a strong relationship.

✅ Example:

class Printer {
    void print(String text) {
        System.out.println(text);
    }
}

class User {
    void usePrinter(Printer p) {   // Dependency (Uses-A)
        p.print("Printing user document...");
    }
}

🔹 Summary Table (Easy to Remember)
Relationship	Keyword / Concept	Example	Lifetime Dependency
IS-A	extends, implements	Car IS-A Vehicle	Parent & Child together
HAS-A (Composition)	Class as a field	Car HAS-A Engine	Strong, owned by parent
HAS-A (Aggregation)	Class as a field (independent)	Department HAS-A Student	Weak, independent
Uses-A (Dependency)	Method parameters	User uses Printer	Temporary

✅ Interview Tip:
If interviewer asks:
👉 "What are class relationships in Java?"
You can say:

Java supports IS-A (inheritance) and HAS-A (composition/aggregation).

Additionally, classes can have dependency relationships (uses-a).

These relationships define how objects interact and how code is reused.

---------------------------------------------------------------------------------------------------------------------------------------

10.Can private keyword be used with constructor?


❓ Can private keyword be used with a constructor in Java?

👉 Yes, we can declare a constructor as private in Java.

✅ Why do we need a private constructor?

A private constructor restricts object creation from outside the class.
It is mainly used in the following scenarios:

1️⃣ Singleton Design Pattern

Ensures that only one instance of a class can exist in the JVM.

Constructor is private, so no other class can create a new object.

The instance is created inside the class and returned through a getInstance() method.

📌 Example:

class Singleton {
    // Step 1: Create a private static instance of the class
    private static Singleton instance;

    // Step 2: Private constructor (no other class can call it)
    private Singleton() {
        System.out.println("Private Constructor Called");
    }

    // Step 3: Public method to provide global access point
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}

public class Main {
    public static void main(String[] args) {
        // Singleton obj1 = new Singleton(); ❌ Error (constructor is private)
        Singleton obj1 = Singleton.getInstance();
        Singleton obj2 = Singleton.getInstance();

        System.out.println(obj1 == obj2); // true (same object)
    }
}


👉 Here, only one object of Singleton is created.


⚠️ Important Points for Interview:

✅ Yes, private constructors are allowed in Java.

✅ They are used to restrict instantiation.

✅ Commonly used in Singleton, Factory Methods, Utility Classes.

❌ If you declare only a private constructor and no public method to create objects → the class cannot be instantiated anywhere.


-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

11. Can we use a package inside another package?


🔹 What is a Package?

A package is a way to group related classes, interfaces, and sub-packages.

It helps in organizing code and avoiding name conflicts.

🔹 Sub-Package

A package inside another package is called a sub-package.

Declared using the . (dot) notation.

Example:

java.util is a sub-package of java

java.sql is also a sub-package of java

🔹 Example: Custom Package with Sub-Package
// File: mypack/MainClass.java
package mypack;

public class MainClass {
    public void display() {
        System.out.println("Hello from MainClass in mypack package!");
    }
}

// File: mypack/subpack/SubClass.java
package mypack.subpack;   // sub-package inside mypack

public class SubClass {
    public void show() {
        System.out.println("Hello from SubClass in mypack.subpack package!");
    }
}

// File: Test.java
import mypack.MainClass;
import mypack.subpack.SubClass;

public class Test {
    public static void main(String[] args) {
        MainClass m = new MainClass();
        m.display();

        SubClass s = new SubClass();
        s.show();
    }
}

🔹 Output
Hello from MainClass in mypack package!
Hello from SubClass in mypack.subpack package!

🔹 Interview Explanation

Yes, we can have a package inside another package (sub-package).

It allows better modularization and layered project structure.

Real-time example:

java.util → has sub-packages like java.util.concurrent, java.util.regex.

In Spring Framework, you’ll see org.springframework.boot, org.springframework.data.jpa, etc. (all sub-packages for modular design).


3. Key Points to Remember (Crucial for Interview)
No Special Access Privileges: A crucial point is that being a subpackage does not grant any special access. The protected and default (package-private) access modifiers are only valid within the exact same package.

A class in com.jarus.drones cannot access a class with default (no modifier) visibility in com.jarus.drones.navigation. They are considered different packages for access control.

Directory Structure Must Match: The physical folder structure on your computer must exactly mirror the package structure.

The class com.jarus.drones.navigation.GPS must be located in the folder com/jarus/drones/navigation/GPS.java.

Imports are Explicit: To use a class from a subpackage, you must import it using its fully qualified name (import com.jarus.drones.navigation.GPS;). You cannot use a wildcard to import all subpackages. import com.jarus.drones.*; will import classes only from the drones package, not from its subpackages like navigation or logistics.

------------------------------------------------------------------------------------------------------------------------------------------

12. How will you declare a Package in Java?

A package in Java is used to group related classes, interfaces, and sub-packages together.
It helps in:

Avoiding name conflicts

Organizing code properly

Providing access protection

Syntax for Declaring a Package
package packageName;


👉 The package statement must be the first statement in your Java file (before imports and class definitions).

Steps to Declare and Use a Package
Step 1: Create a Package

Let’s say we want to create a package called myPackage.

// File: MyClass.java
package myPackage;   // Declaring the package

public class MyClass {
    public void displayMessage() {
        System.out.println("Hello from MyClass inside myPackage!");
    }
}


Now compile it with:

javac -d . MyClass.java


-d . tells Java to place compiled classes in the correct package folder (it creates a myPackage directory automatically).

Step 2: Use the Package

Now create another file TestPackage.java in the default folder:

// File: TestPackage.java
import myPackage.MyClass;   // Import the class from myPackage

public class TestPackage {
    public static void main(String[] args) {
        MyClass obj = new MyClass();
        obj.displayMessage();
    }
}


Compile and run:

javac TestPackage.java
java TestPackage


✅ Output:

Hello from MyClass inside myPackage!

Types of Packages in Java

Built-in Packages → Already available in Java (e.g., java.util, java.io, java.sql).

User-defined Packages → Created by programmers (like the example above).

📌 In simple words:
Declaring a package = package packageName; at the top of your file.
It groups related classes together, just like putting books into the right bookshelf.

-----------------------------------------------------------------------------------------------------------------


13. How to create a class inside a package which is in another package in Java?

👉 In Java, we can create sub-packages (a package inside another package). This is often used to organize large projects better.

For example:

Suppose we have a parent package: com.company

Inside it, we create a sub-package: com.company.hr

Inside hr, we will create a class: Employee.

Step 1: Declare the package

At the top of the class file, we declare the package hierarchy:

package com.company.hr;

public class Employee {
    private String name;
    private int id;

    public Employee(String name, int id) {
        this.name = name;
        this.id = id;
    }

    public void display() {
        System.out.println("Employee ID: " + id + ", Name: " + name);
    }
}


Here, the class Employee belongs to package com.company.hr, which is a sub-package of com.company.

Step 2: Using the class from another package

Now, let’s say we have a Main class in another package:

package com.company;

import com.company.hr.Employee;  // importing from sub-package

public class Main {
    public static void main(String[] args) {
        Employee emp = new Employee("John", 101);
        emp.display();
    }
}

Step 3: Folder Structure

Java enforces the folder structure to match the package structure:

src/
 └── com/
      └── company/
           ├── Main.java
           └── hr/
                └── Employee.java

✅ Interview Explanation

Yes, we can create a class inside a package that is inside another package (sub-package).

We just need to declare the full package name at the top using package keyword.

When using it elsewhere, we import it using import package.subpackage.ClassName.

This helps in modularity, code reusability, and better organization of large projects.

⚡ Example analogy:
Think of package as a folder in your computer. A sub-package is a sub-folder inside it. A class is like a file inside the folder.

--------------------------------------------------------------------------------------------------------------

14.Do you know about input stream


What is an InputStream?
In simple terms, an InputStream is a Java class that represents a flow of incoming data from a source. Think of it as a pipe that brings data into your program. The data is read sequentially, one piece at a time, in the form of raw bytes.

The source of this data can be almost anything:

A file on your disk

A network connection (like a web page being downloaded)

A peripheral device (like a keyboard or microphone)

An array of bytes in memory

Another program's output (through a pipe)

🔹 What is InputStream in Java?

InputStream is an abstract class in Java (from java.io package).

It is the superclass of all classes that represent an input stream of bytes.

Used to read data (input) from sources like:

Files

Keyboard

Network connections

Byte arrays, etc.

The InputStream Hierarchy
InputStream is an abstract class at the top of a hierarchy. This means you typically use one of its concrete subclasses, each designed for a specific type of input source.

text
java.lang.Object
  └── java.io.InputStream (Abstract Class)
        ├── FileInputStream (for reading files)
        ├── ByteArrayInputStream (for reading from a byte array)
        ├── FilterInputStream
        │     ├── BufferedInputStream (wraps another stream for efficiency)
        │     └── DataInputStream (for reading primitive data types)
        ├── ObjectInputStream (for reading serialized objects)
        └── ... and many others


🔹 Key Points

Belongs to package:

import java.io.InputStream;


Reads 8-bit bytes (not characters → for characters we use Reader).

Being abstract, it cannot be used directly. Instead, we use its subclasses:

FileInputStream

ByteArrayInputStream

BufferedInputStream

ObjectInputStream

PipedInputStream

It provides methods for reading data.

🔹 Important Methods of InputStream
int read()  


Reads one byte of data.

Returns -1 if the end of the stream is reached.

int read(byte[] b)  


Reads bytes into an array b[].

int read(byte[] b, int off, int len)  


Reads up to len bytes into the array starting from index off.

void close()  


Closes the stream and releases resources.

int available()  


Returns the number of bytes that can be read without blocking.

🔹 Example 1: Reading file using FileInputStream
import java.io.*;

public class InputStreamExample {
    public static void main(String[] args) {
        try {
            // Create FileInputStream object
            InputStream input = new FileInputStream("example.txt");

            // Read one byte at a time
            int data;
            while ((data = input.read()) != -1) {
                System.out.print((char) data); // convert byte to char
            }

            input.close(); // close stream
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}


✅ Reads content of example.txt byte by byte and prints to console.

🔹 Example 2: Reading with byte array (faster)
import java.io.*;

public class InputStreamArrayExample {
    public static void main(String[] args) {
        try {
            InputStream input = new FileInputStream("example.txt");

            byte[] buffer = new byte[20]; // read in chunks
            int bytesRead = input.read(buffer);

            System.out.println("Read " + bytesRead + " bytes.");
            System.out.println(new String(buffer)); // convert bytes → String

            input.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}


✅ Reads data in chunks instead of one byte at a time.


🔹 Real-World Uses

Reading data from files.

Reading binary data like images, audio, or video streams.

Reading data from network sockets.

Reading input from a System.in (keyboard input).


Important Note: InputStream vs. Reader
This is a common point of confusion.

InputStream and its subclasses are for reading raw bytes (binary data). Perfect for images, audio, ZIP files, or any data where the exact bytes matter.

Reader and its subclasses (like FileReader) are for reading text (characters). They convert bytes into characters using a character encoding (like UTF-8). Use these for reading text files.

Analogy: An InputStream gives you the raw 1s and 0s. A Reader interprets those 1s and 0s as letters and words according to a dictionary (the encoding).
-------------------------------------------------------------------------------------------------------------------------------------------------------------------

What is an OutputStream?
An OutputStream is the opposite of an InputStream. It's a Java class that represents a flow of outgoing data from your program to a destination. Think of it as a pipe that sends data out. You write raw bytes sequentially into this pipe, and they are delivered to a target.

The destination of this data can be:

A file on your disk (to create or overwrite it)

A network connection (to send data to a server)

A peripheral device (like a printer)

An array of bytes in memory

Another program's input (through a pipe)

The OutputStream Hierarchy
Just like InputStream, OutputStream is an abstract class at the top of a hierarchy. You use one of its concrete subclasses for a specific type of output destination.

text
java.lang.Object
  └── java.io.OutputStream (Abstract Class)
        ├── FileOutputStream (for writing to files)
        ├── ByteArrayOutputStream (for writing to a byte array in memory)
        ├── FilterOutputStream
        │     ├── BufferedOutputStream (wraps another stream for efficiency)
        │     └── DataOutputStream (for writing primitive data types)
        │     └── PrintStream (for writing formatted text, e.g., System.out)
        ├── ObjectOutputStream (for writing serialized objects)
        └── ... and others


🔹 Common Methods in OutputStream

Since it’s abstract, subclasses implement the actual writing.
Key methods are:

void write(int b)

Writes a single byte (lower 8 bits of the int).

Example: output.write(65); // writes 'A'.

void write(byte[] b)

Writes an entire byte array to the output.

void write(byte[] b, int off, int len)

Writes part of a byte array (from index off to off+len).

void flush()

Forces any buffered data to be written immediately.

void close()

Closes the stream and releases resources.

🔹 Real-time Examples of OutputStream
1. Writing to a File
import java.io.FileOutputStream;
import java.io.OutputStream;

public class OutputStreamExample {
    public static void main(String[] args) {
        try {
            OutputStream os = new FileOutputStream("output.txt");
            
            String data = "Hello, OutputStream!";
            os.write(data.getBytes()); // converting string to byte[]
            
            os.close();
            System.out.println("Data written successfully!");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}


✅ This writes the text "Hello, OutputStream!" into output.txt.

2. Writing into Byte Array (In-memory)
import java.io.ByteArrayOutputStream;

public class ByteArrayOutputExample {
    public static void main(String[] args) {
        try {
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            String msg = "Data in Memory!";
            
            baos.write(msg.getBytes());
            
            // Convert byte array back to string
            String result = baos.toString();
            System.out.println("Stored: " + result);
            
            baos.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}


✅ Instead of writing to a file, this stores the data in memory (useful for temporary storage).
------------------------------------------------------------------------------------------------------------------------

16.What type of conventions do you follow while naming the identifiers


Of course. Following naming conventions is crucial for writing clean, maintainable, and professional Java code. It's not just about making the code work; it's about making it readable for other developers (and for your future self).

Here are the standard Java naming conventions I follow for identifiers, broken down by type.

The Golden Rule: CamelCase
Java primarily uses camelCase naming, where the first word is lowercase and each subsequent word starts with an uppercase letter. There are two variations:

lowerCamelCase: myVariableName, calculateTotalDistance()

UpperCamelCase (PascalCase): String, DroneController, GlobalConfig

Conventions by Identifier Type
1. Classes and Interfaces
Convention: UpperCamelCase (PascalCase)

Rule: Use nouns (or adjective-noun combinations) that describe the object. Should be concise and meaningful.

Examples:

class Drone { ... }

class AutonomousNavigationSystem { ... }

interface FlightController { ... }

class String (from Java itself)

class HashMap

2. Methods
Convention: lowerCamelCase

Rule: Use verbs or verb phrases that describe the action performed by the method.

Examples:

drone.takeOff()

drone.calculateBatteryLife()

sensor.getCurrentReading()

isActive() (methods that return a boolean often start with 'is', 'has', 'can', etc.)

setCoordinates(double lat, double lon) (setter method)

3. Variables (Local, Instance, and Static Variables)
Convention: lowerCamelCase

Rule: Use short, meaningful nouns or abbreviations. The name should describe the data the variable holds.

Examples:

int droneId;

double maximumAltitude;

boolean isConnected;

String destinationCoordinates;

List<Sensor> sensorList;

4. Constants (Static Final Variables)
Convention: UPPERCASE_SNAKE_CASE

Rule: Use all uppercase letters with words separated by underscores. The name should be fully descriptive.

Examples:

public static final double MAX_SPEED_KNOTS = 120.5;

public static final String COMPANY_NAME = "JARUS";

private static final int TIMEOUT_DURATION_MS = 5000;

5. Packages
Convention: all.lowercase.separated.dots

Rule: Use the reverse of your organization's domain name to ensure uniqueness. Use only lowercase letters.

Examples:

com.jarus.drones.navigation

org.apache.commons.math

java.util (from Java itself)

6. Type Parameters (Generics)
Convention: Single, uppercase letter

Rule: Common conventions are:

E - Element (used extensively by the Java Collections Framework)

K - Key

V - Value

T - Type

N - Number

S, U, V etc. - 2nd, 3rd, 4th types

Examples:

public class Drone<T extends Payload> { ... }

public interface Map<K, V> { ... }

public List<E> getSensorReadings() { ... }

Summary Table for Quick Reference
Identifier Type	Naming Convention	Example
Class / Interface	UpperCamelCase	Drone, AutopilotSystem
Method	lowerCamelCase	calculateRoute(), isAirborne()
Variable	lowerCamelCase	batteryLevel, gpsCoordinates
Constant	UPPER_SNAKE_CASE	MAX_ALTITUDE, LOG_FILE_PATH
Package	all.lowercase	com.jarus.drones.flightcontrol
Generic Type	Single Uppercase Letter	T, K, V, E
Why These Conventions Matter (The "Why")
Readability: Code is read far more often than it is written. calculateFlightPath() is instantly understandable; cFP() is not.

Maintainability: Consistent naming makes it easier for you and other developers to navigate, understand, and modify code, especially in large projects.

Reduced Errors: Following conventions helps avoid simple mistakes. For example, you know System is a class and out is a static variable just by looking at their case.

Professionalism: It shows that you care about your craft and makes your code look like it was written by a seasoned professional, which is exactly what an interviewer wants to see.

Real-World Analogy: A Well-Organized Workshop
Think of your codebase like a workshop.

Classes are like big tools (Table Saw, Drill Press). You label them with clear, descriptive names.

Methods are the actions those tools perform (Saw.cut(), DrillPress.boreHole()).

Variables are like materials and parts (oakBoard, halfInchScrew, bluePaint). You label bins clearly so you know what's inside.

Constants are the unchangeable rules of the workshop (MAX_VOLTAGE=240, SAFETY_GOGGLES_REQUIRED=true). These are posted prominently on the wall in all caps.

----------------------------------------------------------------------------------------------------------------------------------------

17.JDBC steps and implementation?


Of course. JDBC (Java Database Connectivity) is a fundamental API for connecting Java applications to databases. Understanding the steps is a classic interview topic.

Here are the standard JDBC steps, explained clearly with a full implementation example.

The 7 Standard Steps of JDBC
Import the Packages

Load and Register the Driver

Establish the Connection

Create a Statement

Execute the Query

Process the Result

Close the Connection

Step-by-Step Implementation

Let's walk through each step with code to connect to a database, query a hypothetical drones table, and print the results.

Step 1: Import the Packages
You need to import the JDBC classes from the java.sql package.

java
// Typically at the top of your Java file
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;
Step 2: Load and Register the Driver (Optional in modern JDBC)
This step tells the JVM which database driver (e.g., for MySQL, PostgreSQL, Oracle) to use. In older JDBC versions, you had to explicitly load the class. Since JDBC 4.0 (Java 6), this is usually automatic due to a service provider mechanism, but it's good to know.

Old Way (Explicitly loading the class):

java
Class.forName("com.mysql.cj.jdbc.Driver"); // Throws ClassNotFoundException
Modern Way (Auto-loaded): You often don't need this line. The driver JAR file is automatically discovered on the classpath.

Step 3: Establish the Connection
This is where you actually connect to your database using DriverManager.getConnection(). You need the database URL, username, and password.

Database URL Format:
jdbc:<subprotocol>:<subname>

MySQL: jdbc:mysql://localhost:3306/jarus_db

PostgreSQL: jdbc:postgresql://localhost:5432/jarus_db

java
// Define connection parameters
String jdbcUrl = "jdbc:mysql://localhost:3306/jarus_db";
String username = "your_username";
String password = "your_password";

// Establish the connection
Connection connection = DriverManager.getConnection(jdbcUrl, username, password);
Step 4: Create a Statement
A Statement object is used to send your SQL queries to the database.

java
Statement statement = connection.createStatement();
Step 5: Execute the Query
Use the Statement object to execute the SQL query.

For SELECT queries (which return data), use executeQuery().

For INSERT, UPDATE, DELETE (which modify data), use executeUpdate().

java
String sqlQuery = "SELECT id, name, status FROM drones WHERE status = 'ACTIVE'";
ResultSet resultSet = statement.executeQuery(sqlQuery); // Use for SELECT
Step 6: Process the Result
The ResultSet object contains the data returned from the query. It behaves like an iterator. You use a while loop to go through each row and methods like getString(), getInt() to get the data from each column.

java
// resultSet.next() moves the cursor to the next row and returns false if no more rows
while (resultSet.next()) {
    int id = resultSet.getInt("id");        // Get data by column name
    String name = resultSet.getString("name");
    String status = resultSet.getString("status");

    // Alternatively, you can get data by column index (starting from 1)
    // int id = resultSet.getInt(1);
    // String name = resultSet.getString(2);

    System.out.println("Drone ID: " + id + ", Name: " + name + ", Status: " + status);
}
Step 7: Close the Connection (Use Try-With-Resources!)
This is the most important step. Database connections are expensive resources. You must close them to avoid leaks. The modern and safest way is to use try-with-resources, which automatically closes the resources for you, even if an exception occurs.

Full Implementation Example (The Right Way)
Here’s the complete code putting all the steps together using try-with-resources:

java
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class JdbcExample {

    public static void main(String[] args) {
        // Database credentials
        String jdbcUrl = "jdbc:mysql://localhost:3306/jarus_db";
        String username = "your_username";
        String password = "your_password";

        // Step 1, 2, 3, 4, 5, 6, 7 are all handled inside the try-with-resources block
        // The Connection, Statement, and ResultSet will be closed automatically
        try (Connection connection = DriverManager.getConnection(jdbcUrl, username, password);
             Statement statement = connection.createStatement();
             ResultSet resultSet = statement.executeQuery("SELECT id, name, status FROM drones")) {

            System.out.println("Connected to the database successfully!");

            // Process the result set
            while (resultSet.next()) {
                int id = resultSet.getInt("id");
                String name = resultSet.getString("name");
                String status = resultSet.getString("status");

                System.out.printf("ID: %d, Name: %s, Status: %s%n", id, name, status);
            }

        } catch (SQLException e) {
            // Handle any SQL errors
            System.err.println("Database error occurred: " + e.getMessage());
            e.printStackTrace();
        }
        // The connection is automatically closed here, even if an exception was thrown.
    }
}
Important Upgrade: Using PreparedStatement
The Statement object is simple but vulnerable to SQL Injection attacks. For any query that involves user input, you should always use PreparedStatement.

Example of PreparedStatement (Highly Recommended):

java
String sql = "SELECT * FROM drones WHERE name = ? AND status = ?"; // '?' are placeholders

try (Connection conn = DriverManager.getConnection(jdbcUrl, username, password);
     PreparedStatement pStatement = conn.prepareStatement(sql)) { // Create PreparedStatement

    // Set the values for the placeholders (index starts at 1)
    pStatement.setString(1, "Explorer-1"); // Set 1st placeholder to "Explorer-1"
    pStatement.setString(2, "ACTIVE");     // Set 2nd placeholder to "ACTIVE"

    try (ResultSet rs = pStatement.executeQuery()) { // Execute the query
        while (rs.next()) {
            // Process results...
        }
    }
} catch (SQLException e) {
    e.printStackTrace();
}
Summary for Your Interview
You can say: "The standard JDBC steps involve loading the driver, establishing a connection, creating a statement, executing the query, processing the result set, and finally closing all resources. The modern best practice is to use try-with-resources to ensure connections are always closed and to use PreparedStatement instead of a regular Statement to prevent SQL injection attacks and for better performance with parameterized queries."

-----------------------------------------------------------------------------------------------------------------------------------------------------------

18.How will you find an error in your code and how will you fix it?


🔹 Q: How will you find an error in your code and how will you fix it?
1️⃣ Types of Errors in Java (with Examples & Fixes)
✅ 1. Compilation Errors

These errors occur before the program runs, when the Java compiler checks syntax and semantics.

Examples:

Missing semicolon

Using the wrong data type

Misspelled variable names

Example:

public class CompileErrorExample {
    public static void main(String[] args) {
        int a = 5
        System.out.println(a);
    }
}


Error Message:

CompileErrorExample.java:3: error: ';' expected
        int a = 5
                ^


Fix: Add the missing semicolon.

int a = 5;

✅ 2. Runtime Errors

Errors that occur while the program is running.

Caused by invalid inputs, null references, or array index issues.

Common ones: NullPointerException, ArrayIndexOutOfBoundsException, ArithmeticException.

Example (NullPointerException):

public class RuntimeErrorExample {
    public static void main(String[] args) {
        String str = null;
        System.out.println(str.length()); // runtime error
    }
}


Error Message:

Exception in thread "main" java.lang.NullPointerException
    at RuntimeErrorExample.main(RuntimeErrorExample.java:4)


Fix: Add null check.

if (str != null) {
    System.out.println(str.length());
} else {
    System.out.println("String is null!");
}

✅ 3. Logical Errors

The program runs successfully but produces wrong results because the logic is incorrect.

Hardest to detect since no error message is shown.

Example:

public class LogicalErrorExample {
    public static void main(String[] args) {
        int sum = 0;
        for (int i = 1; i <= 5; i++) { // logic mistake
            sum += i;
        }
        System.out.println("Sum = " + sum); // Expected 10, got 15
    }
}


Fix: Correct the loop logic.

for (int i = 1; i < 5; i++) {  // corrected condition
    sum += i;
}

🔍 Steps to Find and Fix Errors in Java

Errors in Java come in two types:

Compile-time errors → found by compiler (syntax mistakes).

Runtime errors → found when the program runs (logic/exception issues).

Now let’s see how to detect and fix them.

1️⃣ Read Error Message (Compiler / Runtime)

Java gives clear error messages with line numbers and error type.

First thing: Read the error message properly.

Example (Compile-time error):
public class Main {
    public static void main(String[] args) {
        int x = "Hello";  // ❌ Type mismatch
    }
}


Error shown:

Main.java:3: error: incompatible types: String cannot be converted to int
        int x = "Hello";
                ^


👉 Fix: Correct data type.

int x = 10; // ✅ fixed

Example (Runtime error):
public class Main {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        System.out.println(arr[5]); // ❌ index out of range
    }
}


Error shown:

Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 5 out of bounds for length 5
    at Main.main(Main.java:4)


👉 Fix: Access correct index.

System.out.println(arr[4]); // ✅ fixed

2️⃣ Use Debugging Tools

Instead of only reading messages, you can debug step by step using an IDE like IntelliJ, Eclipse, VS Code.

Set breakpoints → pause program at a specific line.

Run in debug mode → program stops at breakpoints.

Step into / step over → move line by line.

Inspect variables → check values at runtime.

Example:
int sum = 0;
for(int i=0; i<=5; i++) {  // maybe bug here
    sum += i;
}
System.out.println("Sum = " + sum);


If you expected sum = 10 but got 15,
👉 Debugger will show that loop runs 6 times (0 to 5).
👉 Fix: change condition to < 5.

for(int i=0; i<5; i++) { // ✅ fixed
    sum += i;
}

3️⃣ Use Print Statements (for Logical Errors)

Sometimes, no compiler/runtime error but output is wrong → logic error.

You can trace values using System.out.println().

Example:
int fact = 1;
for(int i=1; i<=5; i++) {
    fact = fact + i;  // ❌ wrong logic, should multiply
}
System.out.println("Factorial = " + fact);


Output:

Factorial = 16  (wrong)


👉 Debug using print:

for(int i=1; i<=5; i++) {
    fact = fact + i;
    System.out.println("i=" + i + " fact=" + fact);
}


This shows values growing wrongly.
👉 Fix:

fact = fact * i; // ✅ multiplication

4️⃣ Unit Testing (JUnit Framework)

For bigger projects, write unit tests for each function.

This helps catch errors automatically.

Example:
public class Calculator {
    public static int add(int a, int b) {
        return a + b;
    }
}


JUnit Test:

import static org.junit.Assert.*;
import org.junit.Test;

public class CalculatorTest {
    @Test
    public void testAddition() {
        assertEquals(10, Calculator.add(5, 5));  // ✅ passes
    }

    @Test
    public void testAdditionFail() {
        assertEquals(12, Calculator.add(5, 5));  // ❌ fails
    }
}


👉 When test fails → we know where the bug is.

✅ Summary

To find and fix errors in Java:

Read error messages carefully → they give line + type of error.

Use debugger tools (breakpoints, step execution, inspect variables).

Add print statements to trace values when logic seems wrong.

Use Unit Testing (JUnit) → automatically detect bugs in methods.



3️⃣ Steps to Fix an Error

Compilation Errors → Fix syntax, missing symbols, or data type mismatches.

Runtime Errors → Add exception handling (try-catch), null checks, bounds checks.

Logical Errors → Review algorithm, debug step by step, compare expected vs actual output.

4️⃣ More Real-Time Examples
🔹 Example 1: Array Index Error
public class ArrayExample {
    public static void main(String[] args) {
        int arr[] = {1, 2, 3, 4, 5};
        System.out.println(arr[5]); // index out of bounds
    }
}


Error:

Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 5 out of bounds for length 5


Fix:

for (int i = 0; i < arr.length; i++) {
    System.out.println(arr[i]);
}


🔹 Example 2: Divide by Zero
public class DivideExample {
    public static void main(String[] args) {
        int a = 10, b = 0;
        System.out.println(a / b); // ArithmeticException
    }
}


Error:

Exception in thread "main" java.lang.ArithmeticException: / by zero


Fix:

if (b != 0) {
    System.out.println(a / b);
} else {
    System.out.println("Cannot divide by zero");
}

✅ Interview-Style Final Answer:

*"In Java, errors are of three main types: compilation errors, runtime errors, and logical errors.
To find errors, I first look at the compiler or runtime error messages which show the type and line number. For logical errors, I use debugging tools like breakpoints in my IDE or print statements to trace variable values. I also write unit tests to validate my code.
To fix errors, I correct syntax for compilation issues, add proper checks or exception handling for runtime errors, and carefully recheck logic for logical errors.

For example, if I face a NullPointerException, I fix it by checking whether the object is null before using it. If an ArrayIndexOutOfBoundsException occurs, I adjust the loop to match the array length. This systematic approach ensures my code runs without errors and produces the expected output."*

--------------------------------------------------------------------------------------------------------------------------------------------
 19.Tell me about Debugger ? Have you ever used it?

What is a Debugger?
A debugger is a software tool used to interactively test and debug other programs. It allows you to pause a running program, inspect its internal state (like variable values), and execute it step-by-step to understand its flow and find the exact point where it goes wrong.

Think of it like a video player for your code:

Running a program normally is like hitting "Play" and watching the whole movie.

Using a debugger is like having a remote control that lets you Pause, Rewind, and Play frame-by-frame to see exactly what each actor (variable) is doing at any moment.

Core Features of a Debugger (The "Remote Control" Buttons)
Any modern debugger, like those built into IntelliJ IDEA, Eclipse, or VS Code, has these key features:

Breakpoints: The most important feature. You can click on the left gutter of your code editor to set a breakpoint (usually a red dot). When the program runs in debug mode, it will pause execution automatically when it hits this line. This allows you to "freeze time" and inspect everything.

Step Through Code: Once paused, you can execute the code line-by-line.

Step Over (F8 in IntelliJ): Executes the current line of code. If the line contains a method call, it executes the entire method and pauses at the next line in the current method. (You ask, "What does this line do?")

Step Into (F7 in IntelliJ): If the current line is a method call, this command "steps into" that method so you can debug its internal code line-by-line. (You ask, "How does this method work?")

Step Out (Shift+F8): Finishes executing the current method and returns to the line where it was called.

Inspecting Variables: While the program is paused, the debugger shows you the current value of every variable in scope. You can hover your mouse over variables or look at a dedicated "Variables" window. This is invaluable for checking if variables contain the values you expect.

The Call Stack: This window shows you the chain of method calls that led to the current point of execution. It answers the question, "How did I get here?"


🔹 How I (or you) would use Debugger in Real Time

I usually use IntelliJ IDEA or Eclipse.

If my code misbehaves (wrong output, infinite loop, null pointer), I set breakpoints near suspicious code.

Then, I run the program in Debug Mode.

I step through line by line, watching how variables change.

This helps me identify whether the issue is in logic, data, or method calls.

🔹 Interview-Friendly Answer

🗣️ “A debugger is a tool that lets me pause execution at specific points and check the values of variables, method calls, and program flow. I have used it in IntelliJ and Eclipse while debugging logical errors, null pointer exceptions, and array index issues. Instead of relying only on print statements, I use breakpoints and step execution to find where the program goes wrong. This has saved me a lot of time while fixing bugs.”


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

20. How do you test your code?

Testing is the process of verifying that the code works as expected and produces the correct output under different conditions. In Java (and in software development generally), I follow different levels of testing:

🔹 1. Manual Testing

Run the program with different inputs and check the output manually.

Example: If I wrote a calculator program, I test with:

Normal input (e.g., 2 + 3 → 5)

Edge input (e.g., 0 + 0 → 0, Integer.MAX_VALUE + 1)

Invalid input (e.g., "abc + 5" → Error handled)

👉 Useful for quick verification, but not enough for large projects.

🔹 2. Debugging with Print Statements

Insert System.out.println() at key points to check variable values and flow.

int sum = a + b;
System.out.println("Sum is: " + sum);


👉 This helps in catching logical errors.

🔹 3. Using Debugger (IDE Tools like Eclipse, IntelliJ, VS Code)

Set breakpoints in the code.

Run the program in debug mode.

Step through the program line by line.

Inspect variable values and memory state.

👉 Example: If a loop runs incorrectly, I check how the index changes at each step.

🔹 4. Unit Testing (JUnit Framework in Java)

Write test cases for each method/class.

Example using JUnit:

import static org.junit.Assert.*;
import org.junit.Test;

public class CalculatorTest {
    @Test
    public void testAddition() {
        assertEquals(10, Calculator.add(5, 5));
    }

    @Test
    public void testDivision() {
        assertEquals(2, Calculator.divide(10, 5));
    }

    @Test(expected = ArithmeticException.class)
    public void testDivisionByZero() {
        Calculator.divide(10, 0);
    }
}


👉 Benefits:

Automated testing

Easy to re-run when code changes

Detects errors early

🔹 5. Integration Testing

Check whether multiple classes/modules work together correctly.

Example: In JDBC, after inserting data into DB → fetch it back → check if it matches.

🔹 6. Exception & Edge Case Testing

Test how program handles unexpected inputs:

Null values

Empty strings

Out-of-bound indexes

Database connection failure

Example:

try {
    int arr[] = {1, 2, 3};
    System.out.println(arr[5]); // will throw exception
} catch (ArrayIndexOutOfBoundsException e) {
    System.out.println("Handled safely!");
}

🔹 7. Performance Testing (Optional in Projects)

Check if the program works efficiently for large input.

Example: Sorting 1,000,000 numbers – does it run within reasonable time?

✅ Final Interview-Style Answer

I test my code in multiple ways. First, I run it manually with different inputs to quickly validate correctness. If something goes wrong, I use print statements or a debugger in my IDE to trace the issue. For proper validation, I write JUnit unit tests so that I can repeatedly test my methods automatically. I also check for edge cases and exceptions, ensuring the program doesn’t break under invalid inputs. In bigger projects, I also perform integration tests to confirm modules work together properly.

--------------------------------------------------------------------------------------------------------------------------------------------------

 21.If you create your own data structure what functions will you include in them?


✅ If I create my own Data Structure, the functions I’ll include depend on what type of data structure I’m building. Let’s consider a few cases:
🔹 1. Custom Array (like Dynamic Array)

Functions to include:

add(element) → insert at the end

insert(index, element) → insert at a specific position

get(index) → fetch value at index

set(index, element) → update value at index

remove(index) → remove element at index

size() → return current number of elements

isEmpty() → check if array is empty

clear() → remove all elements

💡 Example:

class MyArray {
    private int[] data;
    private int size;

    public MyArray(int capacity) {
        data = new int[capacity];
        size = 0;
    }

    public void add(int value) {
        data[size++] = value;
    }

    public int get(int index) {
        return data[index];
    }

    public int size() {
        return size;
    }
}

🔹 2. Custom Stack

Functions to include:

push(element) → add element to the top

pop() → remove and return top element

peek() → return top element without removing

isEmpty() → check if stack is empty

size() → return number of elements

💡 Example use case: Browser back button, undo functionality.

🔹 3. Custom Queue

Functions to include:

enqueue(element) → add element at rear

dequeue() → remove element from front

peek() → see the front element

isEmpty() → check if empty

size() → get number of elements

💡 Example use case: Printer jobs, order processing.

🔹 4. Custom Linked List

Functions to include:

addFirst(element) → add at beginning

addLast(element) → add at end

removeFirst() → remove from beginning

removeLast() → remove from end

get(index) → get element at index

size() → get length

isEmpty() → check if list is empty

🔹 5. Custom HashMap

Functions to include:

put(key, value) → insert/update a key-value pair

get(key) → retrieve value by key

remove(key) → delete entry

containsKey(key) → check if key exists

size() → number of key-value pairs

isEmpty()

🎯 Interview Answer (Summary)

"If I were to create my own data structure, I would include the basic operations like insertion, deletion, search, update, and traversal. For example, if it’s a Stack, I would implement push, pop, and peek. If it’s a Queue, I’d include enqueue and dequeue. And for a custom Array or List, I’d add functions like add, get, remove, and size. Essentially, the functions depend on the data structure, but they should support efficient access, modification, and error handling."
-------------------------------------------------------------------------------------------------------------------------------------------------

22.Difference between data structure and data types?


🔹 1. Definition

Data Type

A data type is a classification that specifies what kind of data a variable can hold.

It defines the nature of the data → whether it’s a number, character, decimal, boolean, or object.

Example:

int → integers like 1, 25, -99

double → decimal values like 3.14, 100.50

char → single character like 'A', 'z'

boolean → true/false

String → sequence of characters

Data Structure

A data structure is a method or model to store, organize, and manipulate data efficiently.

It defines the organization of data and provides operations like insertion, deletion, traversal, searching, and sorting.

Example:

Array

Stack

Queue

Linked List

Tree, Graph

👉 Key difference: Data type tells you what kind of data, data structure tells you how that data is stored and accessed.

🔹 2. Level

Data Type → Low-level, primitive building blocks.

Data Structure → Higher-level, built using data types.

For example:

int rollNo = 101; // Data type - primitive
int[] rollNos = {101, 102, 103}; // Data structure (Array) built on int

🔹 3. Purpose

Data Type → Represents a single unit of data.

Data Structure → Represents a collection of data items and defines how they are related and manipulated.

Example:

int age = 21; → just a single piece of information.

List<Integer> ages = Arrays.asList(21, 22, 23); → multiple ages stored and can be looped, sorted, etc.

🔹 4. Operations

Data Type → Direct arithmetic and logical operations.

+, -, *, /, %, <, > etc.

Data Structure → Specialized operations like:

Array → index-based access, traversal

Stack → push, pop, peek

Queue → enqueue, dequeue

Linked List → insert, delete, traverse

Tree → insert node, delete node, preorder/postorder traversal

Graph → BFS, DFS, shortest path

🔹 5. Example in Java
// Data Types
int age = 25;             // integer type
double salary = 55000.5;  // floating point type
char grade = 'A';         // character type
boolean isPassed = true;  // boolean type

// Data Structure
int[] marks = {90, 85, 75, 95}; // Array
Stack<Integer> stack = new Stack<>(); // Stack
stack.push(10);
stack.push(20);
System.out.println(stack.pop()); // Output: 20

🔹 6. Real-Life Analogy

Data Type → Like a single item type in a shop (pen, notebook, eraser).

Data Structure → Like a storage shelf/box where multiple items are arranged systematically for quick access.

Example:

int → a single pen.

Array of int → a box containing 100 pens arranged in order.

Stack → pile of books one on top of another (LIFO).

Queue → people standing in a ticket line (FIFO).


------------------------------------------------------------------------------------------------------------------------------


23.Explain how java works like jdk, jvm and jre?


Of course. This is a fundamental and very common interview question. Understanding the roles of JDK, JRE, and JVM is crucial to understanding how Java itself works.

Let's break it down in a clear, structured way.

The High-Level Analogy: Building and Running a Car
Think of creating and running a Java program like building and driving a car:

JDK (Java Development Kit): This is the entire car factory. It contains all the tools you need to build a car from scratch: the welding machines, the assembly robots, the paint shop, and even the designs and rules for what a car should be.

JRE (Java Runtime Environment): This is the garage and the road-worthy parts of a car. You don't need the entire factory to drive a car. You just need a place to keep it (the garage) and the key components that make it run (the engine, wheels, etc.). Similarly, the JRE is what you need to run a Java program, but not to create one.

JVM (Java Virtual Machine): This is the car's engine. It's the core component that actually makes the program "go". It takes the fuel (the compiled Java code) and runs it. The magic of Java "write once, run anywhere" happens because this "engine" can be installed on any platform (Windows, Mac, Linux, etc.), so the same fuel can run on any car that has this engine.

Detailed Explanation of Each Component
1. JVM (Java Virtual Machine) - The "Engine"
What it is: The JVM is an abstract computing machine. It's a specification that describes how a program should be executed. It's the core of Java's "Write Once, Run Anywhere" (WORA) capability.

What it does:

Loads Code: The JVM reads the compiled Java code (bytecode).

Verifies Code: It checks the code for security and integrity issues.

Executes Code: It interprets (or uses a Just-In-Time compiler to compile) the bytecode into native machine code (0101) for the specific operating system it's running on.

Provides Runtime Environment: It manages memory (through garbage collection) and provides the environment where the Java program runs.

Key Point: The JVM is platform-dependent. You need a different JVM for Windows, Linux, and macOS. But the bytecode it executes is the same everywhere.

2. JRE (Java Runtime Environment) - The "Garage & Running Gear"
What it is: The JRE is a software package that contains everything needed to run a Java application. It is the implementation of the JVM.

What it contains:

JVM: The engine to run the code.

Libraries (Java Class Libraries): A collection of pre-written code (like java.lang, java.util, java.math) that Java programs need to function. These are the ready-made parts your car uses, like the headlights and steering wheel.

Other Files: Support files like property files and resources.

Who needs it? End-users who only want to run Java applications (like a Minecraft player or someone using a Java-based desktop app). They do not need the development tools.

Key Point: If you only want to run Java programs, you install the JRE.

3. JDK (Java Development Kit) - The "Complete Factory"
What it is: The JDK is a software development kit that contains everything needed to develop Java applications.

What it contains:

JRE: So you can run the code you write.

Development Tools: The most important ones are:

javac (Java Compiler): Translates your human-readable .java source code into JVM-readable .class bytecode.

java (Java Launcher): Starts the JVM and executes the bytecode.

jar: Packages compiled classes into a JAR file (a Zip file for Java code).

javadoc: Generates documentation from your code comments.

Debuggers, etc.

Who needs it? Java Developers. If you want to write, compile, and package Java code, you need the JDK.

How They Work Together: The Java Workflow
The following diagram visualizes the relationship and the process of writing, compiling, and running a Java program:

Diagram
Code
flowchart TD
    A[Programmer writes<br>.java source code] --> B[JDK's javac compiler<br>compiles code to bytecode]
    B --> C[Bytecode stored in<br>.class files]

    subgraph D [JRE provides runtime environment]
        E[JVM loads & verifies bytecode]
        E --> F[JVM interprets/JIT-compiles<br>bytecode to machine code]
        F --> G[JVM executes program<br>on specific OS hardware]
    end

    C --> E

------------------------------------------------------------------------------------------------------------------------------------------------------------------



What is an Exception?
An exception is an unwanted or unexpected event that occurs during the execution of a program (at runtime). These events are essentially objects that are "thrown" by the Java runtime system when an error occurs.

Real-world analogy: Imagine you're driving a car (your program is running).

Normal flow: You press the accelerator, the car moves.

Exception: The car runs out of fuel, a tire blows out, or the engine overheats. This is an unexpected event that disrupts your journey.

Exception handling: What you do when that happens—pulling over safely, calling a tow truck, etc. It's the plan for dealing with the problem.

The Hierarchy of Exceptions
Understanding this hierarchy is key to understanding how to handle them.

text
Throwable (The root class)
│
├── Error (Serious, usually unrecoverable problems)
│    ├── OutOfMemoryError
│    └── StackOverflowError
│
└── Exception (The parent of all "handlable" problems)
     │
     ├── RuntimeException (Unchecked Exceptions)
     │    ├── NullPointerException
     │    ├── ArrayIndexOutOfBoundsException
     │    ├── ArithmeticException (e.g., division by zero)
     │    └── IllegalArgumentException
     │
     └── All other subclasses (Checked Exceptions)
          ├── IOException
          ├── FileNotFoundException
          ├── SQLException
          └── ClassNotFoundException
1. Checked Exceptions
What they are: Exceptions that are checked by the compiler at compile-time.

Rule: You MUST handle them. If your code might throw a checked exception, the compiler will force you to either:

catch it, or

declare that your method throws it.

Examples: IOException, SQLException. These often involve external resources that might fail (files, networks, databases).

2. Unchecked Exceptions (RuntimeException and its subclasses)
What they are: Exceptions that are not checked by the compiler at compile-time.

Rule: Handling them is optional. The compiler won't force you.

Why: They typically represent programming bugs, like logic errors or improper use of an API (e.g., accessing a null reference, using an invalid array index).

Examples: NullPointerException, ArrayIndexOutOfBoundsException.

3. Errors
What they are: Serious problems that are not meant to be caught by the application.

Why: They are external to the application and often related to the JVM itself (e.g., running out of memory).

Examples: OutOfMemoryError, StackOverflowError.

How to Handle Exceptions: The "Try-Catch" Block
This is the primary mechanism for handling exceptions. You put the risky code in a try block and the handling code in a catch block.

Syntax:

java
try {
    // Risky code that might throw an exception
    // e.g., reading a file, dividing numbers, accessing an array
} catch (ExceptionType name) {
    // Code to handle the exception
    // This block is only executed if the exception occurs
}
Example 1: Handling ArithmeticException (Unchecked)

java
public class ExceptionHandlingExample {
    public static void main(String[] args) {
        int a = 10;
        int b = 0;

        try {
            // This line might throw an ArithmeticException
            int result = a / b;
            System.out.println("Result is: " + result);
        } catch (ArithmeticException e) {
            // This block runs ONLY if the exception occurs
            System.err.println("Error: Cannot divide by zero!");
            // e.printStackTrace(); // Optional: prints the full error details
        }

        System.out.println("Program continues after the try-catch block.");
    }
}
Output:

text
Error: Cannot divide by zero!
Program continues after the try-catch block.
Key Point: Without the try-catch block, the program would have crashed at the division line. With it, the error is caught, handled gracefully, and the program continues.

Example 2: Handling IOException (Checked)
The compiler forces you to handle this.

java
import java.io.*;

public class FileExample {
    public void readFile() {
        // The compiler will ERROR here if you don't handle FileNotFoundException
        try {
            FileReader file = new FileReader("nonexistentfile.txt");
        } catch (FileNotFoundException e) {
            System.out.println("Sorry, I couldn't find that file.");
            e.printStackTrace();
        }
    }
}
The Full Mechanism: try-catch-finally
You can add a finally block to the structure. The code inside a finally block always executes, whether an exception occurs or not.

Why is this crucial? It's the perfect place to put cleanup code, like closing files, database connections, or network sockets. This ensures resources are freed even if something goes wrong.

Syntax:

java
try {
    // Risky code
} catch (ExceptionType e) {
    // Handle exception
} finally {
    // Cleanup code (always executes)
}
Example:

java
import java.io.*;

public class FinallyExample {
    public static void main(String[] args) {
        FileReader reader = null;
        try {
            reader = new FileReader("somefile.txt");
            // Read from the file...
            int data = reader.read();
            // Let's simulate an exception
            int badMath = 10 / 0; // This will throw an ArithmeticException!

        } catch (IOException | ArithmeticException e) { // Catching multiple exceptions
            System.out.println("An error occurred: " + e.getMessage());
        } finally {
            System.out.println("This 'finally' block is executing for cleanup.");
            // This code runs no matter what happened in the try or catch blocks.
            if (reader != null) {
                try {
                    reader.close(); // Ensure the file is always closed!
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
Output:

text
An error occurred: / by zero
This 'finally' block is executing for cleanup.
Even though an exception was thrown, the finally block ran and ensured the file was closed.

Alternative to Handling: The throws Keyword
Sometimes, it's better for the method that generates the exception to not handle it itself. Instead, it can "duck" the responsibility and let the caller of the method handle it. This is done using the throws clause in the method signature.

Example:

java
import java.io.*;

public class ThrowsExample {

    // This method declares it might throw a FileNotFoundException.
    // It does NOT handle it itself.
    public void readFile() throws FileNotFoundException {
        FileReader file = new FileReader("nonexistentfile.txt");
        // ... other code ...
    }

    // Now, the main method must handle the exception thrown by readFile()
    public static void main(String[] args) {
        ThrowsExample example = new ThrowsExample();
        try {
            example.readFile(); // Call the risky method
        } catch (FileNotFoundException e) {
            System.out.println("Main method handled the exception.");
        }
    }
}
Summary for Your Interview
"Exception handling in Java is managed through a try-catch-finally mechanism. Code that might throw an exception is placed inside a try block. If an exception occurs, it is caught and handled in a corresponding catch block. The finally block is used for cleanup code and always executes, regardless of whether an exception was thrown."

"Java has two main types of exceptions: checked exceptions, which the compiler forces you to handle, and unchecked exceptions (RuntimeExceptions), which are usually programming errors and optional to handle. If a method doesn't want to handle an exception itself, it can declare that it throws the exception for its caller to handle."

-----------------------------------------------------------------------------------------------------------------------------
