🌐 DBMS Architecture

A Database Management System (DBMS) Architecture describes how database systems are structured, how data flows, and how users interact with the database.

There are mainly 3 types of DBMS architecture:

   -> 1-Tier Architecture (Single-Tier)

   ->  2-Tier Architecture (Client-Server)

    -> 3-Tier Architecture (Three-Layered)


1️⃣ One-Tier Architecture (Single-Tier)

    *  In this type, the database and the user interface both exist on the same machine.

    * The user can directly access the database.

    * It is mainly used for development, testing, and learning purposes.

✅ Example:

A student running Oracle/MySQL database on his laptop and directly writing SQL queries in the same machine.

-- Example Query (Single-Tier)
SELECT * FROM Students WHERE Grade = 'A';

⚡ Limitation: Not suitable for large-scale systems (no security, no concurrent access handling).


2️⃣ Two-Tier Architecture (Client-Server)

* Here, the system is divided into Client and Server.

* Client: Application where the user interacts (like Java, Python, or GUI tool).

* Server: The DBMS that processes queries and manages the database.

* Communication happens via ODBC / JDBC drivers.

✅ Example:

A banking application where the desktop app (client) sends SQL queries to the database server.

📌 Working:

* Client requests → SELECT balance FROM Accounts WHERE AccountNo=101;

* Server (DBMS) processes it.

* Server sends result back to client.

⚡ Limitation: Tight coupling between client and server. If many clients request simultaneously, performance may reduce.


3️⃣ Three-Tier Architecture (Most Popular)

 * Introduces a middle layer (Application Server) between Client and DB Server.

 * Layers:

       1.Presentation Layer (Client) – user interface (mobile app, website).

        2.Application Layer (Server/Business Logic) – processes client requests, applies business logic, communicates with DB.

        3.Database Layer (DB Server) – actual database (MySQL, Oracle, PostgreSQL).

✅ Example:

* E-commerce Website (like Amazon):

       * Client (Browser/App) – Customer searches for “Shoes”.

        * Application Server – Receives request, checks stock, applies discount logic.

         * Database Server – Fetches product data from DB and sends it back.

📌 Flow Example (SQL in 3-Tier):

     1.User: Search “Shoes” → Enters keyword in website.

    2.Application Server: Converts it into query → SELECT * FROM Products WHERE Category='Shoes';

     3. DB Server: Executes query and returns results.
      
     4. Application Server: Formats result and sends JSON/HTML to Client.

⚡ Advantages:

       *  High security (DB not directly exposed).
        
        *  Scalability (can handle millions of users).
        
        *  Separation of concerns (UI, Logic, Data are independent).

-----------------------------------------------------------------------------------

🌐 Specialization in DBMS

In DBMS (Database Management System), Specialization is a top-down approach in Entity-Relationship (ER) modeling where a higher-level entity is divided into two or more lower-level sub-entities (subclasses) based on their distinguishing characteristics.

->It is the reverse of Generalization.

         * Generalization: Bottom-up (combining similar entities into a higher-level entity).
         
        * Specialization: Top-down (splitting a higher-level entity into more specific sub-entities).

🔑 Definition

Specialization is the process of creating subclasses (child entities) from a superclass (parent entity) in ER diagrams to represent entity sets with unique attributes or behaviors.

📌 Example of Specialization

Consider an Employee entity in a company:

->Superclass (Parent): Employee

       * Attributes: Emp_ID, Name, Address

Now, employees can be of two special categories:

        1. Manager
         
               *  Extra Attribute: Bonus, Dept_Name
         
         2.Engineer
         
               * Extra Attribute: Skill, Project_Assigned

✅ So here, Employee is specialized into Manager and Engineer.

📌 ER Representation:

          Employee
     ------------------
     Emp_ID, Name, Address
          /       \
 Manager             Engineer
(Dept, Bonus)     (Skill, Project)

----------------------------------------------------------------------------------------

🌐 Generalization in DBMS

🔑 Definition

Generalization is a bottom-up approach in ER (Entity-Relationship) modeling where two or more lower-level entities are combined into a higher-level entity (superclass) based on common attributes.

👉 It is the reverse of specialization.

  * Specialization: Top-down (divide a superclass into subclasses).

   * Generalization: Bottom-up (combine subclasses into a superclass).

📌 Example of Generalization
Case 1: Student and Teacher

Entities:

        *  Student (RollNo, Name, Address, Course)
         
        *  Teacher (Emp_ID, Name, Address, Subject)

Both have common attributes → Name, Address

✅ We generalize them into a Person entity:

 ->Person (Person_ID, Name, Address)

     *  Subclass Student adds Course
      
     *  Subclass Teacher adds Subject

📌 ER Representation:

      Student         Teacher
        |                 |
        -------------------
              Person
       (Person_ID, Name, Address)

Case 2: Savings Account & Current Account

       *   SavingsAccount (Acc_No, Balance, InterestRate)
         
        *  CurrentAccount (Acc_No, Balance, OverdraftLimit)

Both have → Acc_No, Balance

✅ Generalized into Account (Acc_No, Balance)

-----------------------------------------------------------------------------
🌐 Abstraction in DBMS
🔑 Definition

Abstraction in DBMS means hiding unnecessary details from the user and showing only the essential information.

It allows users to interact with the database without worrying about how data is stored internally.

👉 It provides data independence (changes in storage do not affect how users see the data).


view1    view2    view3
   \       |       /
    \      |      /
     logical level
           |
     physical level


📌 Levels of Abstraction in DBMS

DBMS provides 3 levels of abstraction as per the 3-schema architecture:

1️⃣ Physical Level (Lowest Level – Internal Schema)
         
        * Describes how data is actually stored in memory/disk.
         
        * Deals with file structure, indexes, hashing, compression, storage blocks.
         
        * Not visible to end-users.
         
        * Used by database administrators (DBAs).

✅ Example:

        * Storing Student(Name, RollNo, Address) table as B+ tree indexes or heap files in memory.
         
        * User doesn’t know if it’s stored as linked lists, arrays, or hash tables.

2️⃣ Logical Level (Conceptual Schema)

        * Describes what data is stored in the database and the relationships among them.
         
        * Provides the entire logical view of the database.
         
        * Used by database designers.

✅ Example:

CREATE TABLE Student (
    RollNo INT PRIMARY KEY,
    Name VARCHAR(50),
    Address VARCHAR(100)
);


At this level, you only know that there is a Student table with RollNo, Name, Address. You don’t care about indexes, file storage, or compression.

3️⃣ View Level (Highest Level – External Schema)

        * Closest to the end users.
         
        * Shows only a part of the database relevant to a user/application.
         
        * Provides multiple views for different users.

✅ Example:

-- A teacher only wants to see student names and roll numbers
CREATE VIEW Student_View AS
SELECT RollNo, Name FROM Student;


Here, the teacher cannot see the Address – only the required data is shown.

🎯 Real-Life Analogy

Think of a car:

      *Physical Level: How engine, gears, and wiring work internally.
      
      * Logical Level: Car as an object with features (speed, fuel, mileage).
      
     * View Level: Driver only sees steering, accelerator, and dashboard (no need to know engine details).
----------------------------------------------------------------------------------------------------------

🌐 Relations in DBMS
🔑 Definition

A Relation in DBMS is basically a table that stores data in the form of rows (tuples) and columns (attributes).

    *  Row (Tuple): A single record.
      
     * Column (Attribute): A property of the entity.
      
     * Domain: The set of possible values an attribute can take.

👉 A database is a collection of relations.

📌 Example of a Relation

Student Relation (Table)

RollNo	Name	 Age	City
101	  Anil	 20	Delhi
102	  Ramesh	 21	Mumbai
103	  Sneha	 19	Hyderabad

   *   Attributes (Columns): RollNo, Name, Age, City
      
    *  Tuples (Rows): Each student record
      
    *  Domain Example: Age → integers between 18 and 25

📌 Properties of a Relation

     1. Unique Rows: No two tuples can be identical.
      
     2. Atomic Values: Each cell contains only a single value (no multi-valued attributes).
      
     3. No Ordering of Tuples: Rows in a relation are unordered.
      
     4. No Ordering of Attributes: Columns can be in any order.
      
     5. Unique Attribute Names: Each column must have a distinct name.

📌 Types of Relations in DBMS (Based on Relationships Between Entities)
1️⃣ One-to-One (1:1)

* One entity is related to exactly one entity of another set.

* Example:

      * Each person has one passport.
      
      * Each passport is assigned to one person.

📌 Tables:

Person(Person_ID, Name, Passport_No)  
Passport(Passport_No, IssueDate)

2️⃣ One-to-Many (1:N)

* One entity in set A can be related to many entities in set B.

* But each entity in set B is related to only one entity in set A.

* Example:

         * One teacher teaches many students.
         
        *  But each student has only one teacher (in that subject).

📌 Tables:

Teacher(Teacher_ID, Name)  
Student(Student_ID, Name, Teacher_ID)

3️⃣ Many-to-One (N:1)

* Opposite of One-to-Many.

* Many entities in set A relate to one entity in set B.

* Example:

     * Many students are assigned to one department.

📌 Tables:

Department(Dept_ID, Dept_Name)  
Student(Student_ID, Name, Dept_ID)

4️⃣ Many-to-Many (M:N)

 * An entity from set A can be related to multiple entities in set B, and vice versa.

 * Example:

         * Students enroll in many courses.
         
         * A course is taken by many students.

📌 Tables:

Student(Student_ID, Name)  
Course(Course_ID, Course_Name)  
Student_Course(Student_ID, Course_ID)   -- Junction table


----------------------------------------------------------------

🌐 Introduction to DBMS
🔑 What is DBMS?

DBMS (Database Management System) is a software system that allows users to:
            
            * Store, manage, and retrieve data efficiently.
            
           * Provide security, consistency, and integrity for data.
            
           * Allow multiple users to access data simultaneously without conflict.

👉 In short:
A DBMS is software to manage databases, ensuring data is well-structured, reliable, and easily accessible.

📌 Examples of DBMS

        *  Relational DBMS (RDBMS): MySQL, Oracle, PostgreSQL, SQL Server.
         
        *  NoSQL DBMS: MongoDB, Cassandra, Redis.
         
        *  Cloud DBMS: Amazon RDS, Google BigQuery, Firebase.

📌 Why DBMS? (Problems with File System Approach)

Before DBMS, data was stored in flat files (like Excel/Notepad). This had issues:

            ❌ Data redundancy (duplicate data across files).
            
            ❌ Inconsistency (same data may be different in different files).
            
            ❌ Difficulty in accessing data (need complex code to search/update).
            
            ❌ Lack of security (anyone can open files).
            
            ❌ Concurrent access problems (two users editing at the same time).

✅ DBMS solves all these problems by providing:

        *  Centralized data storage
         
         * Controlled access
         
        *  Query languages (SQL)
         
        * Data integrity rules

📌 Components of DBMS

        1. Hardware → Physical devices where data is stored (disk, memory, server).
         
        2. Software → DBMS software (MySQL, Oracle, MongoDB).
         
        3. Data → The actual information (tables, records, relationships).
         
        4. Users → Different types:
         
                 * Database Administrator (DBA) – manages DB.
                  
                *  Application Programmers – write programs using DB.
                  
                 * End Users – access DB using applications.

📌 Functions of DBMS

      ✅ Data Storage Management – efficient storage & indexing.
      
      ✅ Data Retrieval (Queries) – SQL queries like SELECT * FROM Students.
      
      ✅ Data Manipulation – INSERT, UPDATE, DELETE.
      
      ✅ Transaction Management – ensures ACID properties (Atomicity, Consistency, Isolation, Durability).
      
      ✅ Security & Authorization – restricts unauthorized access.
      
      ✅ Concurrency Control – supports multiple users at the same time.
      
      ✅ Backup & Recovery – restores data after failure.

📌 Advantages of DBMS

      1.Reduced data redundancy
      
      2.Improved data consistency
      
      3.Better security
      
     4. Data independence (changes in storage don’t affect users)
      
     5. Concurrent access support
      
     6. Backup and recovery

📌 Disadvantages of DBMS

        1. Costly to purchase and maintain (especially large systems).
         
        2. Requires skilled administrators.
         
        3. High hardware & software requirements.
         
        4. Complex to manage compared to simple file systems.

📌 Example – Banking System

Customers → stored in Customer table.

Accounts → stored in Account table.

Transactions → stored in Transaction table.

✅ A query like:

SELECT Balance FROM Account WHERE Acc_No = 12345;


will quickly fetch a customer’s balance – without searching through hundreds of files.

🎯 Interview Questions

Q: What is DBMS?
→ DBMS is software that manages databases, providing ways to store, retrieve, and secure data efficiently.

Q: Difference between DBMS and RDBMS?

DBMS: Stores data as files, may not enforce relationships (e.g., MS Access).

RDBMS: Stores data in tables with relationships using primary & foreign keys (e.g., MySQL, Oracle).

Q: What are ACID properties?

Atomicity: Transaction is all-or-nothing.

Consistency: DB must remain valid after transactions.

Isolation: Transactions don’t interfere with each other.

Durability: Data remains permanent after commit.

Q: What are some real-life applications of DBMS?

Banking (transactions)

E-commerce (products, users, orders)

Railway/Airline reservations

Social media (users, posts, comments)
---------------------------------------------------------
🔑 Keys in DBMS

A Key in DBMS is an attribute (or a set of attributes) that is used to uniquely identify records (tuples) in a table.
Keys are very important for maintaining data integrity, uniqueness, and establishing relationships between tables.

✅ Types of Keys in DBMS
1. Super Key

     * Definition: A set of one or more attributes that can uniquely identify a record in a table.
      
     * It may contain extra attributes that are not necessary for uniqueness.
      
     * Every table must have at least one super key.

Example:
Employee table:

EmpID	     EmpName	    Email	            Phone
101	     Rahul	    rahul@gmail.com       9876543210
	
102	     Priya	    priya@gmail.com       9123456789
	

* Possible Super Keys:

       *  {EmpID}
         
        * {Email}
         
        * {Phone}

{EmpID, Email}, {EmpID, Phone}, etc. (contain extra attributes but still unique)

2. Candidate Key
   * Definition: A minimal super key, meaning the smallest set of attributes that can uniquely identify a record.
         
   * A table may have multiple candidate keys.

Example:
       *  From above table:
         
       *  {EmpID}, {Email}, {Phone} → all are Candidate Keys.
         
       * But {EmpID, Email} is not a candidate key because EmpID alone is enough.

3. Primary Key
      
     * Definition: A chosen candidate key that uniquely identifies records in a table.
      
     * Properties:

                 * Cannot contain NULL values.
                  
                 * Must be unique.
                  
                 * Only one primary key per table.

Example:
If we choose EmpID as the Primary Key → every employee will be uniquely identified.

4. Alternate Key

       *  Definition: Candidate keys that are not selected as the primary key.
         
        * They still can uniquely identify records but are not used as the main key.

Example:

        * Candidate Keys = {EmpID}, {Email}, {Phone}
         
        * Primary Key = {EmpID}
         
        * Alternate Keys = {Email}, {Phone}

5. Foreign Key

          *  Definition: An attribute in one table that refers to the Primary Key of another table.
            
           * It establishes relationships between tables.
            
           * Ensures referential integrity.

Example:

       *  Employee Table: EmpID (Primary Key)
         
       *  Department Table: DeptID (Primary Key), EmpID (Foreign Key)

This means each department is linked to an employee using EmpID.

6. Composite Key

         * Definition: A key that consists of two or more attributes to uniquely identify a record.
         
        *  Used when a single attribute is not enough.

Example:

StudentID	CourseID	 Grade
  1	         101	  A
  1	         102	  B
  2	         101	  A

* Neither StudentID nor CourseID alone is unique.

* Together {StudentID, CourseID} forms a Composite Key.

7. Unique Key

      * Definition: Similar to Primary Key but:
      
              * Allows only one NULL value (unlike Primary Key which doesn’t allow any).
      
               * A table can have multiple unique keys.

Example:
In Employee table:

       *Email and Phone can be defined as Unique Keys (but only one NULL allowed).

8. Surrogate Key

     * Definition: An artificial key created by the system (not derived from data).
      
     * Usually an auto-increment integer.
      
     * Useful when natural keys (like Email, Phone) may change.

Example:

     * Customer Table: CustomerID (Auto Generated, Primary Key), Name, Email.
      
     * CustomerID = Surrogate Key.

-------------------------------------------------------------------------------------------

ER Model in DBMS
🔹 What is ER Model?

       *  ER Model (Entity-Relationship Model) is a high-level data model used to design the logical structure of a database.
         
       *  It was proposed by Peter Chen in 1976.
         
        * The main goal of ER modeling is to represent real-world entities and the relationships between them in a clear and structured way.
         
        * It is mainly represented by an ER Diagram (ERD).

🔹 Components of ER Model

1. Entity

      * An entity is an object in the real world that has an independent existence and can be uniquely identified.
      
      * It can be physical (student, car, employee) or conceptual (course, department, project).

👉 Example:

    * Student, Teacher, Course are entities in a university database.

📌 Types of Entities:

       *  Strong Entity → Has its own primary key.
         Example: Student (Student_ID)
         
        * Weak Entity → Cannot be uniquely identified without a strong entity.
         Example: Dependent (depends on Employee).

2. Attributes

   * Attributes are the properties/characteristics of an entity.

📌 Types of Attributes:

             *  Simple Attribute → Cannot be divided.
               Example: Name, Age
               
             *  Composite Attribute → Can be divided into smaller attributes.
               Example: FullName → {FirstName, LastName}
               
            *   Derived Attribute → Can be derived from other attributes.
               Example: Age can be derived from Date_of_Birth.
               
              * Multi-valued Attribute → Can have multiple values.
               Example: PhoneNumbers of a student.
               
             *  Key Attribute → Uniquely identifies an entity.
               Example: Roll_No for Student.

3. Relationship

      * A relationship defines how two or more entities are related to each other.

📌 Types of Relationships:

        * One-to-One (1:1) → One entity is related to exactly one other entity.
         Example: Each passport belongs to only one citizen.
         
        * One-to-Many (1:N) → One entity is related to many entities.
         Example: One teacher teaches many students.
         
        * Many-to-Many (M:N) → Many entities are related to many entities.
         Example: A student can enroll in many courses, and each course has many students.

4. Relationship Degree

     * Unary (1 entity involved)
      Example: An employee supervises another employee.
      
     * Binary (2 entities involved)
      Example: A student enrolls in a course.
      
     * Ternary (3 entities involved)
      Example: A doctor prescribes a medicine to a patient.

5. ER Diagram Symbols
            
           * Entity → Rectangle
            
           * Weak Entity → Double Rectangle
            
           * Relationship → Diamond
            
           * Attributes → Oval
            
           * Key Attribute → Oval with underline
            
           * Multi-valued Attribute → Double Oval

🔹 Example ER Model (University Database)

👉 Consider a University Database with entities:

           * Student (Student_ID, Name, Age, Email, Phone)
            
           * Course (Course_ID, Course_Name, Credits)
            
           * Professor (Prof_ID, Name, Dept)

📌 Relationships:

       *  A student enrolls in many courses. (Many-to-Many)
         
       *  A professor teaches many courses. (One-to-Many)

ER Diagram (Textual Representation):

[STUDENT] ------<Enrolls>------ [COURSE]
   |                                |
(Student_ID PK)               (Course_ID PK)
Name                          Course_Name
Age                           Credits
Email

[PROFESSOR] ------<Teaches>------ [COURSE]
   |
(Prof_ID PK)
Name
Dept

🔹 Advantages of ER Model

         * Provides a clear blueprint for database design.
         
         * Easy to understand for non-technical users.
         
         * Identifies entities, attributes, and relationships before implementation.
         
         * Helps in removing data redundancy.
--------------------------------------------------------------------------------------------------
🔹 What are Integrity Constraints?

		*	Integrity Constraints are rules that ensure the accuracy and consistency of data in a relational database.
			
		 *	They are applied on tables (relations) to make sure only valid data gets stored.
			
	    	*Example: You can’t have a student without an ID or an age as negative.

🔹 Types of Integrity Constraints
1. Domain Constraint

	*	Ensures that the value of an attribute (column) falls within a valid domain (data type + allowed range).
		
	 *	Example:

CREATE TABLE Student (
    RollNo INT,
    Name VARCHAR(50),
    Age INT CHECK (Age >= 18)
);


✅ Allowed: Age = 20
❌ Not Allowed: Age = 15

2. Entity Integrity Constraint

	*	Every table must have a Primary Key, and it cannot be NULL.
		
	*	Ensures each row is unique and identifiable.
		
	*	Example:

CREATE TABLE Student (
    RollNo INT PRIMARY KEY,
    Name VARCHAR(50),
    Age INT
);


❌ Not Allowed: INSERT INTO Student VALUES (NULL, 'John', 22);
(Because RollNo is NULL → violates entity integrity)

3. Referential Integrity Constraint

		* Ensures Foreign Key values must match a Primary Key in another table or be NULL.
		
		 * Prevents invalid references (dangling references).
		
		* Example:

CREATE TABLE Department (
    DeptID INT PRIMARY KEY,
    DeptName VARCHAR(50)
);

CREATE TABLE Employee (
    EmpID INT PRIMARY KEY,
    Name VARCHAR(50),
    DeptID INT,
    FOREIGN KEY (DeptID) REFERENCES Department(DeptID)
);


✅ Allowed: INSERT INTO Employee VALUES (1, 'Alice', 101); if DeptID=101 exists in Department.
❌ Not Allowed: INSERT INTO Employee VALUES (2, 'Bob', 999); (since DeptID=999 doesn’t exist).

4. Key Constraints

	* Ensures unique identification of records.
	
	* Types:

			* Primary Key → Unique & Not NULL
			
			* Unique Key → Unique but allows NULL
			
			* Foreign Key → Refers to Primary Key of another table

Example:

CREATE TABLE Student (
    RollNo INT PRIMARY KEY,
    Email VARCHAR(50) UNIQUE
);


* Two students cannot have the same RollNo or same Email.

5. Check Constraint

	*	Ensures values satisfy a specific condition.
		
	*	Example:

CREATE TABLE Account (
    AccNo INT PRIMARY KEY,
    Balance DECIMAL CHECK (Balance >= 0)
);


❌ Not Allowed: INSERT INTO Account VALUES (101, -500);

6. Not Null Constraint

		* Ensures a column cannot have NULL values.
		
		* Example:

CREATE TABLE Student (
    RollNo INT PRIMARY KEY,
    Name VARCHAR(50) NOT NULL
);


❌ Not Allowed: INSERT INTO Student VALUES (1, NULL);

--------------------------------------------------------------------------------------------

Data Models in DBMS
1. What is a Data Model?

A Data Model in DBMS is a way to describe how data is represented, stored, and manipulated in a database.
It provides the framework for designing the database and ensures that the relationships among data are clearly defined.

👉 In short, a data model = blueprint of how data is organized.

2. Types of Data Models

There are mainly three categories of data models:

A. High-Level / Conceptual Data Models

			* Focus on what data is stored and how different data are related.
			
			* They are close to how humans view data (not computers).
			
			* Used during database design.
			
			* Example: Entity-Relationship (ER) Model.

Example:

		* Entities: Student, Course
		
		* Relationship: Student ENROLLED_IN Course

This model doesn’t worry about how data is stored physically, just the relationships.

B. Representational / Implementation Data Models

		* Show how the database will look in the DBMS.
		
		* Closer to the way a DBMS organizes data.
		
		* Example: Relational Model (most widely used).

Relational Model Example:
We represent Student and Course as tables:

Student Table

Student_ID 	Name	Age
1         	Alice	20
2	        Bob	    21

Course Table

Course_ID	Course_Name
C1       	DBMS
C2	        Networks

Relationship (Enrollment Table)

Student_ID	Course_ID
1	          C1
2	          C2

C. Low-Level / Physical Data Models

		* Define how data is stored physically in the database.
		
		* Concerned with files, indexes, storage blocks, pointers.
		
		* Closest to computer hardware.

Example:

		* Student data stored in memory as heap files,
		
		* Index created on Student_ID for fast search,
		
		* Records stored in pages (blocks).

4. Why are Data Models Important?

✅ Provide a clear structure of data.
✅ Help in designing a database schema.
✅ Make communication between designers, developers, and end-users easier.
✅ Improve data integrity and avoid redundancy.

--------------------------------------------------------------------------------------------------


🔹 What are Anomalies in DBMS?

When a database is not properly normalized (i.e., not structured well), storing and retrieving data can cause problems. These problems are called Anomalies.

They usually happen when data is stored in a single large table (un-normalized table) instead of breaking it into smaller related tables.

There are 3 main types of anomalies:

	1	Insertion Anomaly
		
	2	Update Anomaly
		
	3	Deletion Anomaly

1️⃣ Insertion Anomaly

👉 Problem while inserting new data into a table.

Example:

Consider this Student_Course table (not normalized):

StudentID	StudentName 	CourseID	CourseName
1	          Raj             C101	     DBMS
2	         Ravi	          C102	      Java

Now suppose we want to add a new course (C103 - Python) which has no students yet.

		* We cannot insert it unless we put a dummy student (e.g., NULL or fake ID).
		
		* That’s the insertion anomaly.

✅ Reason: Course information depends on Student information. We can’t insert a course without a student.

2️⃣ Update Anomaly

👉 Problem while updating duplicate data in multiple places.

Example:

In the same table:

StudentID	StudentName	CourseID	CourseName
1	         Raj	     C101	    DBMS
2	         Ravi	     C101	    DBMS

Now suppose the course name DBMS is changed to "Advanced DBMS".

		* We must update it everywhere it appears.
		
		* If we forget to update one row, we will have inconsistent data:

					* Raj → "Advanced DBMS"
					
					* Ravi → "DBMS"

This is an update anomaly.

✅ Reason: Same data is stored redundantly in multiple rows.

3️⃣ Deletion Anomaly

👉 Problem when deleting one data unintentionally removes another important data.

Example:

Our table:

StudentID	StudentName	CourseID	CourseName
1            	Raj	      C101	      DBMS
2	            Ravi	   C102	       Java

If Ravi drops the course Java and we delete his record,
➡ We also lose the information that Java course (C102) exists.

This is a deletion anomaly.

✅ Reason: Course information is dependent on student presence.

🔹 Why do anomalies occur?

		* Because the table has redundant data.
		
		* Multiple pieces of information are stored together in one table.
		
		* Dependencies are not properly separated.

----------------------------------------------------------------------------------------------------------

🔹 What is Functional Dependency?

A functional dependency (FD) is a relationship between attributes in a relation (table).
It means:
👉 If two tuples (rows) have the same values for attribute X, they must also have the same value for attribute Y.
We write this as:

    X → Y   (X functionally determines Y)


Example:

			* In a Student table(StudentID, Name, Dept, CGPA)
			
			* StudentID → Name, Dept, CGPA
			Because StudentID uniquely determines all other details.

🔹 Properties of Functional Dependencies

These are also called Armstrong’s Axioms. They help us derive all possible FDs from a given set.

1. Reflexivity Rule

If Y is a subset of X, then

X → Y


✅ Example:

     {StudentID, Name} → StudentID (because StudentID is part of X)

2. Augmentation Rule

If X → Y, then for any attribute set Z:

XZ → YZ


👉 Adding the same set Z to both sides still holds.

✅ Example:

		If StudentID → Name, then
		{StudentID, Dept} → {Name, Dept}

3. Transitivity Rule

If X → Y and Y → Z, then

X → Z


✅ Example:

	*	StudentID → Dept
		
	*	Dept → HOD
		
	*	So, StudentID → HOD

4. Union (Additivity) Rule

If X → Y and X → Z, then

X → YZ


✅ Example:

		* StudentID → Name
		
		* StudentID → Dept
		
		* So, StudentID → {Name, Dept}

5. Decomposition Rule

If X → YZ, then

X → Y  and  X → Z


✅ Example:

		* StudentID → {Name, Dept}
		
		* So, StudentID → Name and StudentID → Dept

6. Pseudo Transitivity Rule

If X → Y and WY → Z, then

WX → Z


✅ Example:

		* StudentID → Dept
		
		* {Dept, Course} → Faculty
		
		* So, {StudentID, Course} → Faculty

🔹 Why are these Properties Important?

			* Used in normalization (removing anomalies).
			
			* Help find candidate keys.
			
			* Used to derive closure of attributes (all attributes functionally determined).
			
			* Ensures data consistency.
---------------------------------------------------------------------------------------------------------

🔹 Types of Functional Dependencies
1. Trivial Functional Dependency
		
	*	A dependency is trivial if the right-hand side is a subset of the left-hand side.
		
	*	Example:

				*	{StudentID, Name} → Name
					(Already Name is part of left-hand side)

2. Non-Trivial Functional Dependency

	*	A dependency is non-trivial if the right-hand side is not a subset of the left-hand side.
		
	*	Example:

				* StudentID → Name
				(Name is not part of StudentID)

3. Completely Non-Trivial FD

		* A dependency is completely non-trivial if LHS and RHS have nothing in common.
		
		* Example:

				* StudentID → Dept
				(StudentID and Dept share nothing in common)

4. Transitive Dependency

		* If X → Y and Y → Z, then X → Z (Indirect dependency).
		
		* Example:

					* StudentID → Dept
					
					* Dept → HOD
					⇒ StudentID → HOD

5. Multivalued Dependency (MVD)

			* When one attribute determines multiple independent attributes.
			
			* Example: In a Student table:

					* StudentID →→ Hobby
					(A student can have many hobbies independent of other attributes)

6. Partial Dependency

			* When a non-prime attribute depends on part of a candidate key (only occurs in composite keys).
			
			 * Example:
			Suppose in a table (StudentID, CourseID, Grade)

						* Candidate Key = {StudentID, CourseID}
						
						* If StudentID → Name, it’s a partial dependency (because Name depends only on StudentID, not whole key).

7. Full Functional Dependency

		* A dependency is full if it depends on the whole composite key, not just a part.
		
		* Example:

				* (StudentID, CourseID) → Grade
				(Grade depends on both StudentID and CourseID together)
-----------------------------------------------------------------------------------------------------------

🔹 What is Attribute Closure?

		*  In DBMS (Database Management Systems),
		the attribute closure of a set of attributes X, denoted as X⁺, is the set of all attributes that can be functionally determined from X using a given set of Functional Dependencies (FDs).

👉 In simple words:
Attribute closure tells us what attributes can be uniquely identified if we know X.

🔹 Why is Attribute Closure important?

		* Used to check if a set of attributes is a candidate key.
		
		* Used in normalization (to remove redundancy).
		
		* Helps in finding minimal keys and testing FD validity.

🔹 Steps to Find Attribute Closure (X⁺)

		1.Start with X⁺ = X (put all attributes of X in closure initially).
		
		2.Look at the given Functional Dependencies (FDs).
		
		       * If left-hand side of FD ⊆ X⁺, then add the right-hand side to X⁺.
		
		3.Repeat until no new attributes can be added.

🔹 Example 1: Simple Attribute Closure

Suppose we have a relation:
R(A, B, C, D)
Functional Dependencies:

	* A → B
	
	* B → C
	
	* C → D

Find closure of A⁺.

Step 1: Start with A⁺

		A⁺ = {A}

Step 2: Apply FDs

		* From A → B → Add B → A⁺ = {A, B}
		
		* From B → C (since B ∈ A⁺) → Add C → A⁺ = {A, B, C}
		
		* From C → D (since C ∈ A⁺) → Add D → A⁺ = {A, B, C, D}

✅ Final Answer: A⁺ = {A, B, C, D}

👉 Means knowing A alone, we can determine all attributes.
So, A is a Candidate Key.

🔹 Example 2: Different Closure

Relation: R(A, B, C, D, E)
Functional Dependencies:

		1.A → BC
		
		2.CD → E
		
		3.B → D
		
		4.E → A

Find closure of A⁺.

Step 1: Start with A⁺

   A⁺ = {A}

Step 2: Apply FDs

			* From A → BC → Add B, C → A⁺ = {A, B, C}
			
			* From B → D (B ∈ A⁺) → Add D → A⁺ = {A, B, C, D}
			
			* From CD → E (C,D ∈ A⁺) → Add E → A⁺ = {A, B, C, D, E}
			
			* From E → A (already in closure, no change).

✅ Final Answer: A⁺ = {A, B, C, D, E}

👉 Means A is a Super Key (and candidate key).

-----------------------------------------------------------------------------------------------------
1. Attribute Closure

👉 The closure of an attribute (or set of attributes) is the set of all attributes that can be functionally determined from it using the given Functional Dependencies (FDs).

We denote closure as X⁺, where X is an attribute set.

2. Steps to find Closure

		1.Start with the attribute set X.
		
		2.Add attributes from FDs where X determines something.
		
		3.Keep applying FDs until no more new attributes can be added.
		
		4.The final set = closure of X (X⁺).

3. Finding Superkey

    * A set of attributes X is a superkey if X⁺ = all attributes of the relation (R).

4. Finding Candidate Key

		* A candidate key is a minimal superkey.
		
		* Minimal means: if you remove any attribute from it, it should not remain a superkey.

5. Example

Relation R(A, B, C, D, E)
Functional Dependencies (FDs):

		1.A → BC
		
		2.CD → E
		
		3.B → D
		
		4.E → A

Step 1: Find closure of attributes

* (i) Closure of A (A⁺):

		* Start: {A}
		
		* A → BC → add B, C → {A, B, C}
		
		* From B → D → add D → {A, B, C, D}
		
		* From CD → E → add E → {A, B, C, D, E}
		✅ So A⁺ = {A, B, C, D, E} = all attributes

👉 A is a superkey.

* (ii) Closure of B (B⁺):

		* Start: {B}
		
		* B → D → {B, D}
		
		* CD → E requires C, not present
		
		* E → A requires E, not present
			✅ So B⁺ = {B, D} → not all attributes
			👉 B is not a superkey.

(iii) Closure of C (C⁺):

		* Start: {C}
		
		* No FD directly from C
		✅ So C⁺ = {C} → not a superkey.

(iv) Closure of CD (CD⁺):

		* Start: {C, D}
		
		* CD → E → {C, D, E}
		
		* E → A → {C, D, E, A}
		
		* A → BC → {C, D, E, A, B}
            ✅ CD⁺ = {A, B, C, D, E} → all attributes

    👉 CD is a superkey.

Step 2: Find Candidate Keys

* We found A is a superkey. Check minimality:

		* Remove A? Nothing left → not superkey.
		   ✅ So A is a candidate key.

* We found CD is a superkey. Check minimality:

			* Remove C → D⁺ = {D} → not superkey
			
			* Remove D → C⁺ = {C} → not superkey
			   ✅ So CD is a candidate key.

✅ Final Answer

		* Superkeys: A, CD, AC, AD, … (and any superset of candidate keys)
		
		* Candidate Keys: A and CD
----------------------------------------------------------------------------------------------------------

🔹 What is Decomposition?

Decomposition means breaking a large relation (table) into two or more smaller relations to remove redundancy, anomalies, and ensure data integrity.

       * Example: If we have a table with too many attributes, we split it into smaller tables.

But while splitting, we must ensure we don’t lose information.

🔹 Types of Decomposition

There are two types:

1 .Lossless Decomposition

2 .Lossy Decomposition

✅ 1. Lossless Decomposition

👉 A decomposition is lossless if we can join the smaller tables back and get the original relation without losing any data.

      * This is the desired property in normalization.

Example of Lossless:

Relation R(A, B, C)
Functional Dependencies: A → B

We decompose R into two relations:

  * R1(A, B)

   * R2(A, C)

Now, when we join R1 and R2 on A, we get back the original table R(A, B, C).

✔ No information is lost → Lossless Decomposition

❌ 2. Lossy Decomposition

👉 A decomposition is lossy if after joining the smaller relations, we don’t get the original relation correctly.
We may get extra tuples (spurious data) or lose some data.

Example of Lossy:

Relation R(A, B, C)
Functional Dependencies: A → B

We decompose R into:

   * R1(A, B)

   * R2(B, C)

Now, when we join R1 and R2 on B, we may get tuples that never existed in the original relation.

This means we got wrong results (extra data) → Lossy Decomposition

🔑 Rule to Check Lossless Decomposition

👉 A decomposition of relation R into R1 and R2 is lossless if:

(R1 ∩ R2) → (R1 OR R2)

In other words:

   * The common attribute(s) between R1 and R2 should be a key in at least one of the relations.

----------------------------------------------------------------------------------------------------------


