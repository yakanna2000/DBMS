🌐 DBMS Architecture

A Database Management System (DBMS) Architecture describes how database systems are structured, how data flows, and how users interact with the database.

There are mainly 3 types of DBMS architecture:

   -> 1-Tier Architecture (Single-Tier)

   ->  2-Tier Architecture (Client-Server)

    -> 3-Tier Architecture (Three-Layered)


1️⃣ One-Tier Architecture (Single-Tier)

    *  In this type, the database and the user interface both exist on the same machine.

    * The user can directly access the database.

    * It is mainly used for development, testing, and learning purposes.

✅ Example:

A student running Oracle/MySQL database on his laptop and directly writing SQL queries in the same machine.

-- Example Query (Single-Tier)
SELECT * FROM Students WHERE Grade = 'A';

⚡ Limitation: Not suitable for large-scale systems (no security, no concurrent access handling).


2️⃣ Two-Tier Architecture (Client-Server)

* Here, the system is divided into Client and Server.

* Client: Application where the user interacts (like Java, Python, or GUI tool).

* Server: The DBMS that processes queries and manages the database.

* Communication happens via ODBC / JDBC drivers.

✅ Example:

A banking application where the desktop app (client) sends SQL queries to the database server.

📌 Working:

* Client requests → SELECT balance FROM Accounts WHERE AccountNo=101;

* Server (DBMS) processes it.

* Server sends result back to client.

⚡ Limitation: Tight coupling between client and server. If many clients request simultaneously, performance may reduce.


3️⃣ Three-Tier Architecture (Most Popular)

 * Introduces a middle layer (Application Server) between Client and DB Server.

 * Layers:

       1.Presentation Layer (Client) – user interface (mobile app, website).

        2.Application Layer (Server/Business Logic) – processes client requests, applies business logic, communicates with DB.

        3.Database Layer (DB Server) – actual database (MySQL, Oracle, PostgreSQL).

✅ Example:

* E-commerce Website (like Amazon):

       * Client (Browser/App) – Customer searches for “Shoes”.

        * Application Server – Receives request, checks stock, applies discount logic.

         * Database Server – Fetches product data from DB and sends it back.

📌 Flow Example (SQL in 3-Tier):

     1.User: Search “Shoes” → Enters keyword in website.

    2.Application Server: Converts it into query → SELECT * FROM Products WHERE Category='Shoes';

     3. DB Server: Executes query and returns results.
      
     4. Application Server: Formats result and sends JSON/HTML to Client.

⚡ Advantages:

       *  High security (DB not directly exposed).
        
        *  Scalability (can handle millions of users).
        
        *  Separation of concerns (UI, Logic, Data are independent).

-----------------------------------------------------------------------------------

🌐 Specialization in DBMS

In DBMS (Database Management System), Specialization is a top-down approach in Entity-Relationship (ER) modeling where a higher-level entity is divided into two or more lower-level sub-entities (subclasses) based on their distinguishing characteristics.

->It is the reverse of Generalization.

         * Generalization: Bottom-up (combining similar entities into a higher-level entity).
         
        * Specialization: Top-down (splitting a higher-level entity into more specific sub-entities).

🔑 Definition

Specialization is the process of creating subclasses (child entities) from a superclass (parent entity) in ER diagrams to represent entity sets with unique attributes or behaviors.

📌 Example of Specialization

Consider an Employee entity in a company:

->Superclass (Parent): Employee

       * Attributes: Emp_ID, Name, Address

Now, employees can be of two special categories:

        1. Manager
         
               *  Extra Attribute: Bonus, Dept_Name
         
         2.Engineer
         
               * Extra Attribute: Skill, Project_Assigned

✅ So here, Employee is specialized into Manager and Engineer.

📌 ER Representation:

          Employee
     ------------------
     Emp_ID, Name, Address
          /       \
 Manager             Engineer
(Dept, Bonus)     (Skill, Project)

----------------------------------------------------------------------------------------

🌐 Generalization in DBMS

🔑 Definition

Generalization is a bottom-up approach in ER (Entity-Relationship) modeling where two or more lower-level entities are combined into a higher-level entity (superclass) based on common attributes.

👉 It is the reverse of specialization.

  * Specialization: Top-down (divide a superclass into subclasses).

   * Generalization: Bottom-up (combine subclasses into a superclass).

📌 Example of Generalization
Case 1: Student and Teacher

Entities:

        *  Student (RollNo, Name, Address, Course)
         
        *  Teacher (Emp_ID, Name, Address, Subject)

Both have common attributes → Name, Address

✅ We generalize them into a Person entity:

 ->Person (Person_ID, Name, Address)

     *  Subclass Student adds Course
      
     *  Subclass Teacher adds Subject

📌 ER Representation:

      Student         Teacher
        |                 |
        -------------------
              Person
       (Person_ID, Name, Address)

Case 2: Savings Account & Current Account

       *   SavingsAccount (Acc_No, Balance, InterestRate)
         
        *  CurrentAccount (Acc_No, Balance, OverdraftLimit)

Both have → Acc_No, Balance

✅ Generalized into Account (Acc_No, Balance)

-----------------------------------------------------------------------------
🌐 Abstraction in DBMS
🔑 Definition

Abstraction in DBMS means hiding unnecessary details from the user and showing only the essential information.

It allows users to interact with the database without worrying about how data is stored internally.

👉 It provides data independence (changes in storage do not affect how users see the data).


view1    view2    view3
   \       |       /
    \      |      /
     logical level
           |
     physical level


📌 Levels of Abstraction in DBMS

DBMS provides 3 levels of abstraction as per the 3-schema architecture:

1️⃣ Physical Level (Lowest Level – Internal Schema)
         
        * Describes how data is actually stored in memory/disk.
         
        * Deals with file structure, indexes, hashing, compression, storage blocks.
         
        * Not visible to end-users.
         
        * Used by database administrators (DBAs).

✅ Example:

        * Storing Student(Name, RollNo, Address) table as B+ tree indexes or heap files in memory.
         
        * User doesn’t know if it’s stored as linked lists, arrays, or hash tables.

2️⃣ Logical Level (Conceptual Schema)

        * Describes what data is stored in the database and the relationships among them.
         
        * Provides the entire logical view of the database.
         
        * Used by database designers.

✅ Example:

CREATE TABLE Student (
    RollNo INT PRIMARY KEY,
    Name VARCHAR(50),
    Address VARCHAR(100)
);


At this level, you only know that there is a Student table with RollNo, Name, Address. You don’t care about indexes, file storage, or compression.

3️⃣ View Level (Highest Level – External Schema)

        * Closest to the end users.
         
        * Shows only a part of the database relevant to a user/application.
         
        * Provides multiple views for different users.

✅ Example:

-- A teacher only wants to see student names and roll numbers
CREATE VIEW Student_View AS
SELECT RollNo, Name FROM Student;


Here, the teacher cannot see the Address – only the required data is shown.

🎯 Real-Life Analogy

Think of a car:

      *Physical Level: How engine, gears, and wiring work internally.
      
      * Logical Level: Car as an object with features (speed, fuel, mileage).
      
     * View Level: Driver only sees steering, accelerator, and dashboard (no need to know engine details).
----------------------------------------------------------------------------------------------------------

🌐 Relations in DBMS
🔑 Definition

A Relation in DBMS is basically a table that stores data in the form of rows (tuples) and columns (attributes).

    *  Row (Tuple): A single record.
      
     * Column (Attribute): A property of the entity.
      
     * Domain: The set of possible values an attribute can take.

👉 A database is a collection of relations.

📌 Example of a Relation

Student Relation (Table)

RollNo	Name	 Age	City
101	  Anil	 20	Delhi
102	  Ramesh	 21	Mumbai
103	  Sneha	 19	Hyderabad

   *   Attributes (Columns): RollNo, Name, Age, City
      
    *  Tuples (Rows): Each student record
      
    *  Domain Example: Age → integers between 18 and 25

📌 Properties of a Relation

     1. Unique Rows: No two tuples can be identical.
      
     2. Atomic Values: Each cell contains only a single value (no multi-valued attributes).
      
     3. No Ordering of Tuples: Rows in a relation are unordered.
      
     4. No Ordering of Attributes: Columns can be in any order.
      
     5. Unique Attribute Names: Each column must have a distinct name.

📌 Types of Relations in DBMS (Based on Relationships Between Entities)
1️⃣ One-to-One (1:1)

* One entity is related to exactly one entity of another set.

* Example:

      * Each person has one passport.
      
      * Each passport is assigned to one person.

📌 Tables:

Person(Person_ID, Name, Passport_No)  
Passport(Passport_No, IssueDate)

2️⃣ One-to-Many (1:N)

* One entity in set A can be related to many entities in set B.

* But each entity in set B is related to only one entity in set A.

* Example:

         * One teacher teaches many students.
         
        *  But each student has only one teacher (in that subject).

📌 Tables:

Teacher(Teacher_ID, Name)  
Student(Student_ID, Name, Teacher_ID)

3️⃣ Many-to-One (N:1)

* Opposite of One-to-Many.

* Many entities in set A relate to one entity in set B.

* Example:

     * Many students are assigned to one department.

📌 Tables:

Department(Dept_ID, Dept_Name)  
Student(Student_ID, Name, Dept_ID)

4️⃣ Many-to-Many (M:N)

 * An entity from set A can be related to multiple entities in set B, and vice versa.

 * Example:

         * Students enroll in many courses.
         
         * A course is taken by many students.

📌 Tables:

Student(Student_ID, Name)  
Course(Course_ID, Course_Name)  
Student_Course(Student_ID, Course_ID)   -- Junction table


----------------------------------------------------------------

🌐 Introduction to DBMS
🔑 What is DBMS?

DBMS (Database Management System) is a software system that allows users to:
            
            * Store, manage, and retrieve data efficiently.
            
           * Provide security, consistency, and integrity for data.
            
           * Allow multiple users to access data simultaneously without conflict.

👉 In short:
A DBMS is software to manage databases, ensuring data is well-structured, reliable, and easily accessible.

📌 Examples of DBMS

        *  Relational DBMS (RDBMS): MySQL, Oracle, PostgreSQL, SQL Server.
         
        *  NoSQL DBMS: MongoDB, Cassandra, Redis.
         
        *  Cloud DBMS: Amazon RDS, Google BigQuery, Firebase.

📌 Why DBMS? (Problems with File System Approach)

Before DBMS, data was stored in flat files (like Excel/Notepad). This had issues:

            ❌ Data redundancy (duplicate data across files).
            
            ❌ Inconsistency (same data may be different in different files).
            
            ❌ Difficulty in accessing data (need complex code to search/update).
            
            ❌ Lack of security (anyone can open files).
            
            ❌ Concurrent access problems (two users editing at the same time).

✅ DBMS solves all these problems by providing:

        *  Centralized data storage
         
         * Controlled access
         
        *  Query languages (SQL)
         
        * Data integrity rules

📌 Components of DBMS

        1. Hardware → Physical devices where data is stored (disk, memory, server).
         
        2. Software → DBMS software (MySQL, Oracle, MongoDB).
         
        3. Data → The actual information (tables, records, relationships).
         
        4. Users → Different types:
         
                 * Database Administrator (DBA) – manages DB.
                  
                *  Application Programmers – write programs using DB.
                  
                 * End Users – access DB using applications.

📌 Functions of DBMS

      ✅ Data Storage Management – efficient storage & indexing.
      
      ✅ Data Retrieval (Queries) – SQL queries like SELECT * FROM Students.
      
      ✅ Data Manipulation – INSERT, UPDATE, DELETE.
      
      ✅ Transaction Management – ensures ACID properties (Atomicity, Consistency, Isolation, Durability).
      
      ✅ Security & Authorization – restricts unauthorized access.
      
      ✅ Concurrency Control – supports multiple users at the same time.
      
      ✅ Backup & Recovery – restores data after failure.

📌 Advantages of DBMS

      1.Reduced data redundancy
      
      2.Improved data consistency
      
      3.Better security
      
     4. Data independence (changes in storage don’t affect users)
      
     5. Concurrent access support
      
     6. Backup and recovery

📌 Disadvantages of DBMS

        1. Costly to purchase and maintain (especially large systems).
         
        2. Requires skilled administrators.
         
        3. High hardware & software requirements.
         
        4. Complex to manage compared to simple file systems.

📌 Example – Banking System

Customers → stored in Customer table.

Accounts → stored in Account table.

Transactions → stored in Transaction table.

✅ A query like:

SELECT Balance FROM Account WHERE Acc_No = 12345;


will quickly fetch a customer’s balance – without searching through hundreds of files.

🎯 Interview Questions

Q: What is DBMS?
→ DBMS is software that manages databases, providing ways to store, retrieve, and secure data efficiently.

Q: Difference between DBMS and RDBMS?

DBMS: Stores data as files, may not enforce relationships (e.g., MS Access).

RDBMS: Stores data in tables with relationships using primary & foreign keys (e.g., MySQL, Oracle).

Q: What are ACID properties?

Atomicity: Transaction is all-or-nothing.

Consistency: DB must remain valid after transactions.

Isolation: Transactions don’t interfere with each other.

Durability: Data remains permanent after commit.

Q: What are some real-life applications of DBMS?

Banking (transactions)

E-commerce (products, users, orders)

Railway/Airline reservations

Social media (users, posts, comments)
---------------------------------------------------------
🔑 Keys in DBMS

A Key in DBMS is an attribute (or a set of attributes) that is used to uniquely identify records (tuples) in a table.
Keys are very important for maintaining data integrity, uniqueness, and establishing relationships between tables.

✅ Types of Keys in DBMS
1. Super Key

     * Definition: A set of one or more attributes that can uniquely identify a record in a table.
      
     * It may contain extra attributes that are not necessary for uniqueness.
      
     * Every table must have at least one super key.

Example:
Employee table:

EmpID	     EmpName	    Email	            Phone
101	     Rahul	    rahul@gmail.com       9876543210
	
102	     Priya	    priya@gmail.com       9123456789
	

* Possible Super Keys:

       *  {EmpID}
         
        * {Email}
         
        * {Phone}

{EmpID, Email}, {EmpID, Phone}, etc. (contain extra attributes but still unique)

2. Candidate Key
   * Definition: A minimal super key, meaning the smallest set of attributes that can uniquely identify a record.
         
   * A table may have multiple candidate keys.

Example:
       *  From above table:
         
       *  {EmpID}, {Email}, {Phone} → all are Candidate Keys.
         
       * But {EmpID, Email} is not a candidate key because EmpID alone is enough.

3. Primary Key
      
     * Definition: A chosen candidate key that uniquely identifies records in a table.
      
     * Properties:

                 * Cannot contain NULL values.
                  
                 * Must be unique.
                  
                 * Only one primary key per table.

Example:
If we choose EmpID as the Primary Key → every employee will be uniquely identified.

4. Alternate Key

       *  Definition: Candidate keys that are not selected as the primary key.
         
        * They still can uniquely identify records but are not used as the main key.

Example:

        * Candidate Keys = {EmpID}, {Email}, {Phone}
         
        * Primary Key = {EmpID}
         
        * Alternate Keys = {Email}, {Phone}

5. Foreign Key

          *  Definition: An attribute in one table that refers to the Primary Key of another table.
            
           * It establishes relationships between tables.
            
           * Ensures referential integrity.

Example:

       *  Employee Table: EmpID (Primary Key)
         
       *  Department Table: DeptID (Primary Key), EmpID (Foreign Key)

This means each department is linked to an employee using EmpID.

6. Composite Key

         * Definition: A key that consists of two or more attributes to uniquely identify a record.
         
        *  Used when a single attribute is not enough.

Example:

StudentID	CourseID	 Grade
  1	         101	  A
  1	         102	  B
  2	         101	  A

* Neither StudentID nor CourseID alone is unique.

* Together {StudentID, CourseID} forms a Composite Key.

7. Unique Key

      * Definition: Similar to Primary Key but:
      
              * Allows only one NULL value (unlike Primary Key which doesn’t allow any).
      
               * A table can have multiple unique keys.

Example:
In Employee table:

       *Email and Phone can be defined as Unique Keys (but only one NULL allowed).

8. Surrogate Key

     * Definition: An artificial key created by the system (not derived from data).
      
     * Usually an auto-increment integer.
      
     * Useful when natural keys (like Email, Phone) may change.

Example:

     * Customer Table: CustomerID (Auto Generated, Primary Key), Name, Email.
      
     * CustomerID = Surrogate Key.

-------------------------------------------------------------------------------------------

ER Model in DBMS
🔹 What is ER Model?

       *  ER Model (Entity-Relationship Model) is a high-level data model used to design the logical structure of a database.
         
       *  It was proposed by Peter Chen in 1976.
         
        * The main goal of ER modeling is to represent real-world entities and the relationships between them in a clear and structured way.
         
        * It is mainly represented by an ER Diagram (ERD).

🔹 Components of ER Model

1. Entity

      * An entity is an object in the real world that has an independent existence and can be uniquely identified.
      
      * It can be physical (student, car, employee) or conceptual (course, department, project).

👉 Example:

    * Student, Teacher, Course are entities in a university database.

📌 Types of Entities:

       *  Strong Entity → Has its own primary key.
         Example: Student (Student_ID)
         
        * Weak Entity → Cannot be uniquely identified without a strong entity.
         Example: Dependent (depends on Employee).

2. Attributes

   * Attributes are the properties/characteristics of an entity.

📌 Types of Attributes:

             *  Simple Attribute → Cannot be divided.
               Example: Name, Age
               
             *  Composite Attribute → Can be divided into smaller attributes.
               Example: FullName → {FirstName, LastName}
               
            *   Derived Attribute → Can be derived from other attributes.
               Example: Age can be derived from Date_of_Birth.
               
              * Multi-valued Attribute → Can have multiple values.
               Example: PhoneNumbers of a student.
               
             *  Key Attribute → Uniquely identifies an entity.
               Example: Roll_No for Student.

3. Relationship

      * A relationship defines how two or more entities are related to each other.

📌 Types of Relationships:

        * One-to-One (1:1) → One entity is related to exactly one other entity.
         Example: Each passport belongs to only one citizen.
         
        * One-to-Many (1:N) → One entity is related to many entities.
         Example: One teacher teaches many students.
         
        * Many-to-Many (M:N) → Many entities are related to many entities.
         Example: A student can enroll in many courses, and each course has many students.

4. Relationship Degree

     * Unary (1 entity involved)
      Example: An employee supervises another employee.
      
     * Binary (2 entities involved)
      Example: A student enrolls in a course.
      
     * Ternary (3 entities involved)
      Example: A doctor prescribes a medicine to a patient.

5. ER Diagram Symbols
            
           * Entity → Rectangle
            
           * Weak Entity → Double Rectangle
            
           * Relationship → Diamond
            
           * Attributes → Oval
            
           * Key Attribute → Oval with underline
            
           * Multi-valued Attribute → Double Oval

🔹 Example ER Model (University Database)

👉 Consider a University Database with entities:

           * Student (Student_ID, Name, Age, Email, Phone)
            
           * Course (Course_ID, Course_Name, Credits)
            
           * Professor (Prof_ID, Name, Dept)

📌 Relationships:

       *  A student enrolls in many courses. (Many-to-Many)
         
       *  A professor teaches many courses. (One-to-Many)

ER Diagram (Textual Representation):

[STUDENT] ------<Enrolls>------ [COURSE]
   |                                |
(Student_ID PK)               (Course_ID PK)
Name                          Course_Name
Age                           Credits
Email

[PROFESSOR] ------<Teaches>------ [COURSE]
   |
(Prof_ID PK)
Name
Dept

🔹 Advantages of ER Model

         * Provides a clear blueprint for database design.
         
         * Easy to understand for non-technical users.
         
         * Identifies entities, attributes, and relationships before implementation.
         
         * Helps in removing data redundancy.
--------------------------------------------------------------------------------------------------
🔹 What are Integrity Constraints?

		*	Integrity Constraints are rules that ensure the accuracy and consistency of data in a relational database.
			
		 *	They are applied on tables (relations) to make sure only valid data gets stored.
			
	    	*Example: You can’t have a student without an ID or an age as negative.

🔹 Types of Integrity Constraints
1. Domain Constraint

	*	Ensures that the value of an attribute (column) falls within a valid domain (data type + allowed range).
		
	 *	Example:

CREATE TABLE Student (
    RollNo INT,
    Name VARCHAR(50),
    Age INT CHECK (Age >= 18)
);


✅ Allowed: Age = 20
❌ Not Allowed: Age = 15

2. Entity Integrity Constraint

	*	Every table must have a Primary Key, and it cannot be NULL.
		
	*	Ensures each row is unique and identifiable.
		
	*	Example:

CREATE TABLE Student (
    RollNo INT PRIMARY KEY,
    Name VARCHAR(50),
    Age INT
);


❌ Not Allowed: INSERT INTO Student VALUES (NULL, 'John', 22);
(Because RollNo is NULL → violates entity integrity)

3. Referential Integrity Constraint

		* Ensures Foreign Key values must match a Primary Key in another table or be NULL.
		
		 * Prevents invalid references (dangling references).
		
		* Example:

CREATE TABLE Department (
    DeptID INT PRIMARY KEY,
    DeptName VARCHAR(50)
);

CREATE TABLE Employee (
    EmpID INT PRIMARY KEY,
    Name VARCHAR(50),
    DeptID INT,
    FOREIGN KEY (DeptID) REFERENCES Department(DeptID)
);


✅ Allowed: INSERT INTO Employee VALUES (1, 'Alice', 101); if DeptID=101 exists in Department.
❌ Not Allowed: INSERT INTO Employee VALUES (2, 'Bob', 999); (since DeptID=999 doesn’t exist).

4. Key Constraints

	* Ensures unique identification of records.
	
	* Types:

			* Primary Key → Unique & Not NULL
			
			* Unique Key → Unique but allows NULL
			
			* Foreign Key → Refers to Primary Key of another table

Example:

CREATE TABLE Student (
    RollNo INT PRIMARY KEY,
    Email VARCHAR(50) UNIQUE
);


* Two students cannot have the same RollNo or same Email.

5. Check Constraint

	*	Ensures values satisfy a specific condition.
		
	*	Example:

CREATE TABLE Account (
    AccNo INT PRIMARY KEY,
    Balance DECIMAL CHECK (Balance >= 0)
);


❌ Not Allowed: INSERT INTO Account VALUES (101, -500);

6. Not Null Constraint

		* Ensures a column cannot have NULL values.
		
		* Example:

CREATE TABLE Student (
    RollNo INT PRIMARY KEY,
    Name VARCHAR(50) NOT NULL
);


❌ Not Allowed: INSERT INTO Student VALUES (1, NULL);

--------------------------------------------------------------------------------------------

Data Models in DBMS
1. What is a Data Model?

A Data Model in DBMS is a way to describe how data is represented, stored, and manipulated in a database.
It provides the framework for designing the database and ensures that the relationships among data are clearly defined.

👉 In short, a data model = blueprint of how data is organized.

2. Types of Data Models

There are mainly three categories of data models:

A. High-Level / Conceptual Data Models

			* Focus on what data is stored and how different data are related.
			
			* They are close to how humans view data (not computers).
			
			* Used during database design.
			
			* Example: Entity-Relationship (ER) Model.

Example:

		* Entities: Student, Course
		
		* Relationship: Student ENROLLED_IN Course

This model doesn’t worry about how data is stored physically, just the relationships.

B. Representational / Implementation Data Models

		* Show how the database will look in the DBMS.
		
		* Closer to the way a DBMS organizes data.
		
		* Example: Relational Model (most widely used).

Relational Model Example:
We represent Student and Course as tables:

Student Table

Student_ID 	Name	Age
1         	Alice	20
2	        Bob	    21

Course Table

Course_ID	Course_Name
C1       	DBMS
C2	        Networks

Relationship (Enrollment Table)

Student_ID	Course_ID
1	          C1
2	          C2

C. Low-Level / Physical Data Models

		* Define how data is stored physically in the database.
		
		* Concerned with files, indexes, storage blocks, pointers.
		
		* Closest to computer hardware.

Example:

		* Student data stored in memory as heap files,
		
		* Index created on Student_ID for fast search,
		
		* Records stored in pages (blocks).

4. Why are Data Models Important?

✅ Provide a clear structure of data.
✅ Help in designing a database schema.
✅ Make communication between designers, developers, and end-users easier.
✅ Improve data integrity and avoid redundancy.

--------------------------------------------------------------------------------------------------


🔹 What are Anomalies in DBMS?

When a database is not properly normalized (i.e., not structured well), storing and retrieving data can cause problems. These problems are called Anomalies.

They usually happen when data is stored in a single large table (un-normalized table) instead of breaking it into smaller related tables.

There are 3 main types of anomalies:

	1	Insertion Anomaly
		
	2	Update Anomaly
		
	3	Deletion Anomaly

1️⃣ Insertion Anomaly

👉 Problem while inserting new data into a table.

Example:

Consider this Student_Course table (not normalized):

StudentID	StudentName 	CourseID	CourseName
1	          Raj             C101	     DBMS
2	         Ravi	          C102	      Java

Now suppose we want to add a new course (C103 - Python) which has no students yet.

		* We cannot insert it unless we put a dummy student (e.g., NULL or fake ID).
		
		* That’s the insertion anomaly.

✅ Reason: Course information depends on Student information. We can’t insert a course without a student.

2️⃣ Update Anomaly

👉 Problem while updating duplicate data in multiple places.

Example:

In the same table:

StudentID	StudentName	CourseID	CourseName
1	         Raj	     C101	    DBMS
2	         Ravi	     C101	    DBMS

Now suppose the course name DBMS is changed to "Advanced DBMS".

		* We must update it everywhere it appears.
		
		* If we forget to update one row, we will have inconsistent data:

					* Raj → "Advanced DBMS"
					
					* Ravi → "DBMS"

This is an update anomaly.

✅ Reason: Same data is stored redundantly in multiple rows.

3️⃣ Deletion Anomaly

👉 Problem when deleting one data unintentionally removes another important data.

Example:

Our table:

StudentID	StudentName	CourseID	CourseName
1            	Raj	      C101	      DBMS
2	            Ravi	   C102	       Java

If Ravi drops the course Java and we delete his record,
➡ We also lose the information that Java course (C102) exists.

This is a deletion anomaly.

✅ Reason: Course information is dependent on student presence.

🔹 Why do anomalies occur?

		* Because the table has redundant data.
		
		* Multiple pieces of information are stored together in one table.
		
		* Dependencies are not properly separated.

----------------------------------------------------------------------------------------------------------

🔹 What is Functional Dependency?

A functional dependency (FD) is a relationship between attributes in a relation (table).
It means:
👉 If two tuples (rows) have the same values for attribute X, they must also have the same value for attribute Y.
We write this as:

    X → Y   (X functionally determines Y)


Example:

			* In a Student table(StudentID, Name, Dept, CGPA)
			
			* StudentID → Name, Dept, CGPA
			Because StudentID uniquely determines all other details.

🔹 Properties of Functional Dependencies

These are also called Armstrong’s Axioms. They help us derive all possible FDs from a given set.

1. Reflexivity Rule

If Y is a subset of X, then

X → Y


✅ Example:

     {StudentID, Name} → StudentID (because StudentID is part of X)

2. Augmentation Rule

If X → Y, then for any attribute set Z:

XZ → YZ


👉 Adding the same set Z to both sides still holds.

✅ Example:

		If StudentID → Name, then
		{StudentID, Dept} → {Name, Dept}

3. Transitivity Rule

If X → Y and Y → Z, then

X → Z


✅ Example:

	*	StudentID → Dept
		
	*	Dept → HOD
		
	*	So, StudentID → HOD

4. Union (Additivity) Rule

If X → Y and X → Z, then

X → YZ


✅ Example:

		* StudentID → Name
		
		* StudentID → Dept
		
		* So, StudentID → {Name, Dept}

5. Decomposition Rule

If X → YZ, then

X → Y  and  X → Z


✅ Example:

		* StudentID → {Name, Dept}
		
		* So, StudentID → Name and StudentID → Dept

6. Pseudo Transitivity Rule

If X → Y and WY → Z, then

WX → Z


✅ Example:

		* StudentID → Dept
		
		* {Dept, Course} → Faculty
		
		* So, {StudentID, Course} → Faculty

🔹 Why are these Properties Important?

			* Used in normalization (removing anomalies).
			
			* Help find candidate keys.
			
			* Used to derive closure of attributes (all attributes functionally determined).
			
			* Ensures data consistency.
---------------------------------------------------------------------------------------------------------

🔹 Types of Functional Dependencies
1. Trivial Functional Dependency
		
	*	A dependency is trivial if the right-hand side is a subset of the left-hand side.
		
	*	Example:

				*	{StudentID, Name} → Name
					(Already Name is part of left-hand side)

2. Non-Trivial Functional Dependency

	*	A dependency is non-trivial if the right-hand side is not a subset of the left-hand side.
		
	*	Example:

				* StudentID → Name
				(Name is not part of StudentID)

3. Completely Non-Trivial FD

		* A dependency is completely non-trivial if LHS and RHS have nothing in common.
		
		* Example:

				* StudentID → Dept
				(StudentID and Dept share nothing in common)

4. Transitive Dependency

		* If X → Y and Y → Z, then X → Z (Indirect dependency).
		
		* Example:

					* StudentID → Dept
					
					* Dept → HOD
					⇒ StudentID → HOD

5. Multivalued Dependency (MVD)

			* When one attribute determines multiple independent attributes.
			
			* Example: In a Student table:

					* StudentID →→ Hobby
					(A student can have many hobbies independent of other attributes)

6. Partial Dependency

			* When a non-prime attribute depends on part of a candidate key (only occurs in composite keys).
			
			 * Example:
			Suppose in a table (StudentID, CourseID, Grade)

						* Candidate Key = {StudentID, CourseID}
						
						* If StudentID → Name, it’s a partial dependency (because Name depends only on StudentID, not whole key).

7. Full Functional Dependency

		* A dependency is full if it depends on the whole composite key, not just a part.
		
		* Example:

				* (StudentID, CourseID) → Grade
				(Grade depends on both StudentID and CourseID together)
-----------------------------------------------------------------------------------------------------------

🔹 What is Attribute Closure?

		*  In DBMS (Database Management Systems),
		the attribute closure of a set of attributes X, denoted as X⁺, is the set of all attributes that can be functionally determined from X using a given set of Functional Dependencies (FDs).

👉 In simple words:
Attribute closure tells us what attributes can be uniquely identified if we know X.

🔹 Why is Attribute Closure important?

		* Used to check if a set of attributes is a candidate key.
		
		* Used in normalization (to remove redundancy).
		
		* Helps in finding minimal keys and testing FD validity.

🔹 Steps to Find Attribute Closure (X⁺)

		1.Start with X⁺ = X (put all attributes of X in closure initially).
		
		2.Look at the given Functional Dependencies (FDs).
		
		       * If left-hand side of FD ⊆ X⁺, then add the right-hand side to X⁺.
		
		3.Repeat until no new attributes can be added.

🔹 Example 1: Simple Attribute Closure

Suppose we have a relation:
R(A, B, C, D)
Functional Dependencies:

	* A → B
	
	* B → C
	
	* C → D

Find closure of A⁺.

Step 1: Start with A⁺

		A⁺ = {A}

Step 2: Apply FDs

		* From A → B → Add B → A⁺ = {A, B}
		
		* From B → C (since B ∈ A⁺) → Add C → A⁺ = {A, B, C}
		
		* From C → D (since C ∈ A⁺) → Add D → A⁺ = {A, B, C, D}

✅ Final Answer: A⁺ = {A, B, C, D}

👉 Means knowing A alone, we can determine all attributes.
So, A is a Candidate Key.

🔹 Example 2: Different Closure

Relation: R(A, B, C, D, E)
Functional Dependencies:

		1.A → BC
		
		2.CD → E
		
		3.B → D
		
		4.E → A

Find closure of A⁺.

Step 1: Start with A⁺

   A⁺ = {A}

Step 2: Apply FDs

			* From A → BC → Add B, C → A⁺ = {A, B, C}
			
			* From B → D (B ∈ A⁺) → Add D → A⁺ = {A, B, C, D}
			
			* From CD → E (C,D ∈ A⁺) → Add E → A⁺ = {A, B, C, D, E}
			
			* From E → A (already in closure, no change).

✅ Final Answer: A⁺ = {A, B, C, D, E}

👉 Means A is a Super Key (and candidate key).

-----------------------------------------------------------------------------------------------------
1. Attribute Closure

👉 The closure of an attribute (or set of attributes) is the set of all attributes that can be functionally determined from it using the given Functional Dependencies (FDs).

We denote closure as X⁺, where X is an attribute set.

2. Steps to find Closure

		1.Start with the attribute set X.
		
		2.Add attributes from FDs where X determines something.
		
		3.Keep applying FDs until no more new attributes can be added.
		
		4.The final set = closure of X (X⁺).

3. Finding Superkey

    * A set of attributes X is a superkey if X⁺ = all attributes of the relation (R).

4. Finding Candidate Key

		* A candidate key is a minimal superkey.
		
		* Minimal means: if you remove any attribute from it, it should not remain a superkey.

5. Example

Relation R(A, B, C, D, E)
Functional Dependencies (FDs):

		1.A → BC
		
		2.CD → E
		
		3.B → D
		
		4.E → A

Step 1: Find closure of attributes

* (i) Closure of A (A⁺):

		* Start: {A}
		
		* A → BC → add B, C → {A, B, C}
		
		* From B → D → add D → {A, B, C, D}
		
		* From CD → E → add E → {A, B, C, D, E}
		✅ So A⁺ = {A, B, C, D, E} = all attributes

👉 A is a superkey.

* (ii) Closure of B (B⁺):

		* Start: {B}
		
		* B → D → {B, D}
		
		* CD → E requires C, not present
		
		* E → A requires E, not present
			✅ So B⁺ = {B, D} → not all attributes
			👉 B is not a superkey.

(iii) Closure of C (C⁺):

		* Start: {C}
		
		* No FD directly from C
		✅ So C⁺ = {C} → not a superkey.

(iv) Closure of CD (CD⁺):

		* Start: {C, D}
		
		* CD → E → {C, D, E}
		
		* E → A → {C, D, E, A}
		
		* A → BC → {C, D, E, A, B}
            ✅ CD⁺ = {A, B, C, D, E} → all attributes

    👉 CD is a superkey.

Step 2: Find Candidate Keys

* We found A is a superkey. Check minimality:

		* Remove A? Nothing left → not superkey.
		   ✅ So A is a candidate key.

* We found CD is a superkey. Check minimality:

			* Remove C → D⁺ = {D} → not superkey
			
			* Remove D → C⁺ = {C} → not superkey
			   ✅ So CD is a candidate key.

✅ Final Answer

		* Superkeys: A, CD, AC, AD, … (and any superset of candidate keys)
		
		* Candidate Keys: A and CD
----------------------------------------------------------------------------------------------------------

🔹 What is Decomposition?

Decomposition means breaking a large relation (table) into two or more smaller relations to remove redundancy, anomalies, and ensure data integrity.

       * Example: If we have a table with too many attributes, we split it into smaller tables.

But while splitting, we must ensure we don’t lose information.

🔹 Types of Decomposition

There are two types:

1 .Lossless Decomposition

2 .Lossy Decomposition

✅ 1. Lossless Decomposition

👉 A decomposition is lossless if we can join the smaller tables back and get the original relation without losing any data.

      * This is the desired property in normalization.

Example of Lossless:

Relation R(A, B, C)
Functional Dependencies: A → B

We decompose R into two relations:

  * R1(A, B)

   * R2(A, C)

Now, when we join R1 and R2 on A, we get back the original table R(A, B, C).

✔ No information is lost → Lossless Decomposition

❌ 2. Lossy Decomposition

👉 A decomposition is lossy if after joining the smaller relations, we don’t get the original relation correctly.
We may get extra tuples (spurious data) or lose some data.

Example of Lossy:

Relation R(A, B, C)
Functional Dependencies: A → B

We decompose R into:

   * R1(A, B)

   * R2(B, C)

Now, when we join R1 and R2 on B, we may get tuples that never existed in the original relation.

This means we got wrong results (extra data) → Lossy Decomposition

🔑 Rule to Check Lossless Decomposition

👉 A decomposition of relation R into R1 and R2 is lossless if:

(R1 ∩ R2) → (R1 OR R2)

In other words:

   * The common attribute(s) between R1 and R2 should be a key in at least one of the relations.

----------------------------------------------------------------------------------------------------------

🔹 What is Normalization?

Normalization is a process in DBMS used to:

			* Organize data into tables.
			
			* Remove redundancy (duplicate data).
			
			* Ensure data integrity (accuracy & consistency).
			
			* Divide large tables into smaller, related tables.

👉 The aim is to make databases efficient and free from anomalies (insertion, update, deletion).

🔹 Types of Normal Forms (Step by Step)
1. First Normal Form (1NF)

👉 A relation is in 1NF if:

			* Each column has atomic (indivisible) values.
			
			* No repeating groups or arrays.
			
			* Each record is unique.

Example (Not in 1NF):

Student Table
+-----------+--------------------+
| StudentID | Subjects           |
+-----------+--------------------+
| 1         | Math, Physics      |
| 2         | Chemistry, Biology |


Here, Subjects has multiple values → ❌ Not atomic.

Convert to 1NF:

+-----------+-----------+
| StudentID | Subject   |
+-----------+-----------+
| 1         | Math      |
| 1         | Physics   |
| 2         | Chemistry |
| 2         | Biology   |


✅ Now each column has atomic values.

2. Second Normal Form (2NF)

👉 A table is in 2NF if:

		1.It is already in 1NF.
		
		2.No partial dependency → i.e., no non-key attribute depends on only part of a composite primary key.

Example (Not in 2NF):

+-----------+-----------+---------+
| StudentID | CourseID  | CourseName |
+-----------+-----------+---------+
| 1         | C101      | DBMS    |
| 2         | C102      | OS      |


Here, (StudentID, CourseID) = Primary Key.
But CourseName depends only on CourseID → Partial dependency ❌.

Convert to 2NF:

Student_Course
+-----------+-----------+
| StudentID | CourseID  |
+-----------+-----------+
| 1         | C101      |
| 2         | C102      |

Course
+-----------+------------+
| CourseID  | CourseName |
+-----------+------------+
| C101      | DBMS       |
| C102      | OS         |


✅ Now no partial dependency.

3. Third Normal Form (3NF)

👉 A table is in 3NF if:

		1.It is in 2NF.
		
		2.No transitive dependency (non-key attributes should not depend on other non-key attributes).

Example (Not in 3NF):

+-----------+-----------+-------------+
| EmpID     | DeptID    | DeptName    |
+-----------+-----------+-------------+
| 1         | D1        | HR          |
| 2         | D2        | Finance     |


Here:

		* EmpID → DeptID
		
		* DeptID → DeptName → Transitive dependency ❌

Convert to 3NF:

Employee
+-----------+-----------+
| EmpID     | DeptID    |
+-----------+-----------+
| 1         | D1        |
| 2         | D2        |

Department
+-----------+-------------+
| DeptID    | DeptName    |
+-----------+-------------+
| D1        | HR          |
| D2        | Finance     |


✅ Transitive dependency removed.

4. Boyce-Codd Normal Form (BCNF)

👉 A stricter version of 3NF.
A table is in BCNF if:

      *  For every functional dependency (X → Y), X should be a super key.

Example (Not in BCNF):

+-----------+-----------+----------+
| StudentID | CourseID  | Teacher  |
+-----------+-----------+----------+
| 1         | DBMS      | Prof A   |
| 2         | OS        | Prof B   |


Here:

		* (StudentID, CourseID) is primary key.
		
		* But CourseID → Teacher (Teacher depends only on CourseID) → violates BCNF ❌.

Convert to BCNF:

Student_Course
+-----------+-----------+
| StudentID | CourseID  |
+-----------+-----------+
| 1         | DBMS      |
| 2         | OS        |

Course_Teacher
+-----------+----------+
| CourseID  | Teacher  |
+-----------+----------+
| DBMS      | Prof A   |
| OS        | Prof B   |


✅ Now dependency preserved properly.

5. Fourth Normal Form (4NF)

👉 A table is in 4NF if:

  * It is in BCNF.

   * No multi-valued dependencies exist.

Example (Not in 4NF):

+-----------+-----------+-----------+
| StudentID | Hobby     | Language  |
+-----------+-----------+-----------+
| 1         | Singing   | English   |
| 1         | Dancing   | English   |
| 1         | Singing   | Hindi     |
| 1         | Dancing   | Hindi     |


Problem: Hobby and Language are independent multi-valued facts → redundancy.

Convert to 4NF:

Student_Hobby
+-----------+-----------+
| StudentID | Hobby     |
+-----------+-----------+
| 1         | Singing   |
| 1         | Dancing   |

Student_Language
+-----------+-----------+
| StudentID | Language  |
+-----------+-----------+
| 1         | English   |
| 1         | Hindi     |


✅ Now no multi-valued dependency.

6. Fifth Normal Form (5NF / PJNF)

✅ A relation is in 5NF if:

		* It is in 4NF.
		
		* It cannot be decomposed into smaller tables without losing information.
		
		* Deals with Join Dependencies.

Example:

Project (ProjectID, SupplierID, PartID)


Here, a project can have multiple suppliers and parts, but supplier and parts are independent.
So we decompose:

Project_Supplier (ProjectID, SupplierID)
Project_Part (ProjectID, PartID)
Supplier_Part (SupplierID, PartID)

🔹 Interview Tip

If interviewer asks:

What is Normalization?
→ "It is the process of organizing data into multiple related tables to reduce redundancy and improve consistency."

Which normal forms are commonly used?
→ "Up to 3NF is mostly used in real projects. BCNF is sometimes applied. 4NF and 5NF are rare in practice."


LET’S START WITH DBMS :)

1.First Normal Form (1NF)
A relation is in 1NF if it contains only atomic values (no multivalued attributes).
Since we are assuming our relation R is in a standard relational model, it is already
in 1NF.

2. Second Normal Form (2NF)
A relation is in 2NF if it is in 1NF and every non-prime attribute is fully functionally
dependent on every candidate key of the relation(P.D ->LHS is a proper subset of
Candidate key AND RHS is a non-prime attribute).

A→BC = no partial dependency (A is a CK)
B→C = no partial dependency (B is a CK)
A→B= no partial dependency (A is a CK)
AB→C= no partial dependency (AB is a combination of candidate keys, Its SK)
B→A= no partial dependency (B is a CK) , R is in 2NF.

LET’S START WITH DBMS :)

3. Third Normal Form (3NF)
A relation is in 3NF if it is in 2NF and no transitive dependency exists.
X->Y (X is a superkey OR Y is a prime attribute if true no transitive dependency)

A→BC = no transitive dependency (A is a CK)
B→C = no transitive dependency (B is a CK)
A→B= no transitive dependency (A is a CK)
AB→C= no transitive dependency (AB is a combination of candidate keys, Its SK)
B→A= no transitive dependency (B is a CK) , R is in 3NF.

LET’S START WITH DBMS :)

4. BCNF
A relation is in BCNF if it is in 3NF and for every functional dependency X→Y, X is a
superkey.

A→BC = A is a CK
B→C = B is a CK
A→B= A is a CK
AB→C= AB is a combination of candidate keys, Its SK
B→A= B is a CK , R is in BCNF.

The highest normal form for the given relation R(A,B,C,D) is BCNF.

LET’S START WITH DBMS :)

How to normalise table

In normalisation we generally break/decompose the table into 2 or more tables.

Steps to normalize a table
1.Write down all the attributes of table, CK, Prime and non-prime attributes and start
analyzing with the FD.
2. For table to be in 1NF : Table should have atomic (indivisible) values and a primary key

3.For table to be in 2NF : No Partial dependency(LHS proper subset of CK and RHS non-
prime attribute should be false)

4. For table to be in 3NF : No transitive dependency(LHS must be a CK or RHS a prime
attribute should be true)
5. For table to be in BCNF : LHS must be a CK or SK
6. If it fails at any of these steps decompose the table on a common attribute which is CK
(lossless)
--------------------------------------------------------------------------------------------------------

🔹 Transaction in DBMS

A transaction is a single logical unit of work that accesses and modifies the database.
Example: In a banking system, transferring ₹500 from Account A to Account B involves:
		
		1.Read balance of A
		
		2.Subtract 500 from A
		
		3.Write updated balance of A
		
		4.Read balance of B
		
		5.Add 500 to B
		
		6.Write updated balance of B

👉 All these steps together form a transaction.
If any step fails (like power failure after step 3), the database should not lose consistency.

ACID Properties in DBMS

In Database Management Systems (DBMS), when we perform a transaction (a sequence of database operations like INSERT, UPDATE, DELETE), it must ensure data correctness, consistency, and reliability even in cases of failures (system crash, power failure, concurrent access, etc.).

To guarantee this, DBMS follows the ACID properties:

🔹 1. Atomicity

* Meaning:
		A transaction is all or nothing.
		Either the entire transaction is executed successfully, or none of it is.

* Example:
		Imagine you are transferring ₹500 from Account A to Account B.
		The transaction has 2 steps:

		1.Deduct ₹500 from A.
		
		2.Add ₹500 to B.

	*  If both succeed, transaction is committed.
	
	* If system crashes after step 1 but before step 2, DBMS must rollback step 1 (so A’s money isn’t lost).

👉 Ensures no partial transaction happens.

🔹 2. Consistency

* Meaning:
		A transaction must bring the database from one valid state to another valid state. Database integrity constraints must not be violated.

* Example:

		* Before transfer: A = ₹1000, B = ₹500 → Total = ₹1500
		
		* After transfer of ₹500: A = ₹500, B = ₹1000 → Total = ₹1500

✔ Total money remains same (consistent).
❌ If after the transaction total = ₹1200 or ₹1800, database is inconsistent.

👉 Ensures rules, constraints, triggers, and data validity remain intact.

🔹 3. Isolation

* Meaning:
  Multiple transactions happening at the same time should not interfere with each other.

* Example:

		* Transaction T1: Transfer ₹500 from A → B
		
		* Transaction T2: Check balance of A

If both run concurrently:

		* Without Isolation, T2 might see A’s balance after deduction but before addition → wrong result.
		
		* With Isolation, T2 executes as if it ran before or after T1, not in the middle.

👉 Prevents dirty reads, non-repeatable reads, phantom reads (covered in Concurrency Control).

🔹 4. Durability

 Meaning:
    Once a transaction is committed, its changes are permanent, even if the system crashes.

 Example:

		* If transfer from A → B is successful and committed,
		
		* Even if the system crashes right after, the updated balances are stored safely (using logs, backups, recovery mechanisms).

👉 Ensures data is never lost after success.
--------------------------------------------------------------------------------------------
🔹 Concurrency in DBMS

   * Concurrency means multiple transactions executing simultaneously in a multi-user database environment.

   * Example: In a banking system, one user transfers money while another checks balance at the same time.

Concurrency is good for performance ✅ but can cause problems (anomalies) if transactions interfere with each other.


⚡ Problems without concurrency control:

1. Lost Update Problem – Two transactions overwrite each other’s updates.
Example:

		* T1 reads balance = 1000, subtracts 200 → new = 800
		
		* T2 reads same balance = 1000, subtracts 100 → new = 900
		
		* Final balance should be 700, but ends up 900 → ❌ wrong.

2.Dirty Read (Temporary Update Problem) – A transaction reads uncommitted changes of another.
Example:

		* T1 updates balance to 800 but crashes (rollback).
		
		* T2 reads 800 (wrong), while actual should remain 1000.

3.Unrepeatable Read – A transaction reads the same data twice but gets different results.
Example:

		* T1 reads balance = 1000
		
		* T2 updates balance to 800 and commits
		
		* T1 reads again → 800 (inconsistent for T1).

4.Phantom Read Problem

* Happens when a transaction re-executes a query and finds different rows due to another transaction inserting/deleting rows.

Example:
		
		* T1: SELECT * FROM students WHERE marks > 90 → gets 5 rows.
		
		* T2: Inserts a new student with marks 95 and commits.
		
		* T1 re-executes query → now gets 6 rows.
		
		* Result is inconsistent. ❌
----------------------------------------------------------------------------------------

🔹 What is a Schedule in DBMS?

		* In a multi-user DBMS, several transactions execute concurrently.
		
		* Each transaction consists of a sequence of read/write operations.
		
		* A Schedule is an ordered sequence of operations (read, write, commit, abort) from multiple transactions, arranged in a way that preserves their order within each transaction.

👉 In simple words: A schedule tells us how operations from different transactions are interleaved.

🔹 Types of Schedules

Schedules are broadly classified into two main categories:

1. Serial Schedule

		* A schedule in which transactions are executed one after the other without overlapping.
		
		* No interleaving of operations.
		
		* Always consistent but not efficient (low concurrency).

✅ Example:
Two transactions:

		* T1 = {R1(A), W1(A)}
		
		* T2 = {R2(B), W2(B)}

Serial Schedule:

R1(A), W1(A), Commit1, R2(B), W2(B), Commit2


Here T1 executes fully, then T2.

2. Non-Serial Schedule

		* A schedule where operations of different transactions are interleaved.
		
		* More efficient (higher concurrency) but may lead to inconsistency if not controlled.

✅ Example:

R1(A), R2(B), W1(A), W2(B), Commit1, Commit2


Here T1 and T2 are interleaved.

🔹 Categories of Schedules in Concurrency Control
(A) Serializable Schedules

A schedule is serializable if it produces the same result as a serial schedule.

👉 Types of Serializability:

1.Conflict Serializable

  * Based on conflicting operations:

     * Two operations conflict if:

			* They belong to different transactions.
			
			* They access the same data item.
			
			* At least one is a write.

* A conflict-serializable schedule can be transformed into a serial schedule by swapping non-conflicting operations.

✅ Example:
T1: R1(A), W1(A)
T2: R2(A), W2(A)

Schedule:

R1(A), R2(A), W1(A), W2(A)


This can be rearranged into a serial schedule, so it is conflict serializable.

2. View Serializable

   * A schedule is view serializable if it is view-equivalent to a serial schedule.

    * Two schedules are view-equivalent if:

			1.Same reads: Each read operation reads the same value in both schedules.
			
			2.Same writes: The final write on each data item is the same in both schedules.

👉 Every conflict serializable schedule is view serializable, but not vice versa.

(B) Recoverability in Schedules

Recoverability deals with whether a failed transaction affects others.

1.Recoverable Schedule

		*  A schedule where a transaction commits only after the transaction it depends on has committed.
		
		* Prevents cascading aborts.

✅ Example:
If T2 reads a value written by T1, then T2 should commit only after T1 commits.

2.Cascadeless Schedule

		* A stricter form of recoverable schedule.
		
		* No transaction reads uncommitted data.
		
		* Prevents cascading rollbacks.

3. Strict Schedule

		* The strictest form.
		
		* Transactions cannot read or write a data item until the last transaction that wrote it has committed/aborted.
		
		* Prevents cascading aborts and ensures strictness.

(C) Other Types of Schedules

1.Complete Schedule

		* Contains all operations (read, write, commit, abort) of all transactions.

2.Irrecoverable Schedule
		
		* A schedule where a transaction commits before the one it depends on.
		
		 * Dangerous because rollback becomes impossible.

🔹 Visual Example of Schedules
Example Transactions:

* T1: R1(A), W1(A)

* T2: R2(A), W2(A)

Serial Schedule:
T1 → T2
R1(A), W1(A), Commit1, R2(A), W2(A), Commit2

Non-Serial, Conflict Serializable:
R1(A), R2(A), W1(A), W2(A), Commit1, Commit2

Non-Serializable (may cause inconsistency):
R1(A), W2(A), W1(A), Commit2, Commit1


Here final value of A depends on execution order → inconsistency.
--------------------------------------------------------------------------------------------
🔹 Concurrency Control Methods in DBMS

Concurrency control methods are techniques used to ensure correct execution of concurrent transactions without violating data consistency, isolation, and integrity.

The main goal is to avoid concurrency problems like dirty reads, lost updates, uncommitted data, and inconsistent data.

✅ 1. Lock-Based Protocols

A lock is a variable associated with a data item that describes the status of the item (locked/unlocked).
Transactions must acquire a lock before accessing a data item.

Types of Locks:

 * Shared Lock (S):

			* Multiple transactions can read (shared) the same item.
			
			* No transaction can write until all shared locks are released.
			
			* Example: T1 and T2 can both read Balance[X].

 * Exclusive Lock (X):

			* Only one transaction can both read and write the item.
			
			* Prevents all others from accessing until unlocked.
			
			* Example: T1 wants to update Balance[X], so T2 cannot read/write X until T1 releases lock.

Two-Phase Locking (2PL) Protocol:

  * Ensures serializability using locks.

  * Has two phases:

		1.Growing Phase: Transaction can acquire locks but cannot release.
		
		2.Shrinking Phase: Transaction releases locks but cannot acquire new ones.

🔹 Example:

		* T1 acquires lock on A, then B → updates.
		
		* Releases locks after finishing.
		
		* If T2 wants A, it must wait until T1 finishes.

👉 Problem: Can lead to deadlock.

✅ 2. Timestamp Ordering Protocol
		
		* Each transaction gets a timestamp (TS) when it starts.
		
		* TS decides the order of conflicting operations.

Rules:

   * If a younger transaction tries to access data already accessed by an older transaction in a conflicting way, the younger one is rolled back.

🔹 Example:

		* T1 (TS=1) and T2 (TS=2) both want to update X.
		
		* Since T1 is older, its write is allowed.
		
		* T2’s conflicting write may be rolled back.

👉 Advantage: Avoids deadlock (no waiting).
👉 Disadvantage: Many rollbacks if transactions conflict often.

✅ 3. Validation (Optimistic Concurrency Control)

Works in 3 phases:

1.Read Phase → Transaction reads data into local workspace.

2.Validation Phase → System checks if transaction conflicts with others.

3.Write Phase → If validation passes, local changes are written to DB.

🔹 Example:

		* T1 reads A=100, adds 10 → A=110 (local).
		
		* T2 reads A=100, subtracts 20 → A=80 (local).
		
		* During validation: Conflict detected.
		
		* One transaction (say T2) is rolled back.

👉 Useful in systems with low conflicts (like OLAP).

✅ 4. Multiversion Concurrency Control (MVCC)

		* Maintains multiple versions of a data item.
		
		* Readers read the latest committed version.
		
		* Writers create a new version instead of blocking readers.

🔹 Example:

		* T1 reads Salary=5000 (version V1).
		
		* T2 updates Salary to 6000 → creates V2.
		
		* T1 still sees V1 until it finishes.
		
		* Later, V2 becomes the latest.

👉 Used in PostgreSQL, Oracle, MySQL InnoDB.
👉 Advantage: Readers never block writers.

✅ 5. Deadlock Handling Methods

When using locks, deadlocks may occur. Handling methods are:

1.Deadlock Prevention:
		
		* Impose an ordering of resources (transactions must request in order).
		
		* Or use wait-die / wound-wait schemes.

2.Deadlock Detection & Recovery:

		* Allow deadlocks.
		
		* Build a wait-for graph.
		
		* Detect cycles → abort a transaction.

3.Deadlock Avoidance:

   * Use Banker’s algorithm to avoid unsafe states.c
